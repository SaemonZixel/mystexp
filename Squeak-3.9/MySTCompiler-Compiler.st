Object subclass: #MySTCompiler	instanceVariableNames: 'globalDict bytecode literals temps arguments instances expressions returnedObj sourcetext postcompileList'	classVariableNames: 'CurrentGlobalDictionary'	poolDictionaries: ''	category: 'MySTCompiler-Compiler'!!MySTCompiler methodsFor: 'initialize-release' stamp: 'SZ 2/2/2008 12:26'!initialize	literals _ OrderedCollection new.	arguments _ Array new.	temps _ Array new.	instances _ Array new.	bytecode _ OrderedCollection new.	postcompileList _ OrderedCollection new.	globalDict  _ MySTCompiler currentGlobalDictionary.	^self.! !!MySTCompiler methodsFor: 'initialize-release' stamp: 'SZ 2/2/2008 12:25'!initializeWith: aString 	"super initializeWith: aString."	sourcetext _ aString.	expressions _ OrderedCollection new.	self collectExpressions: (MySTLexicalAnalyzerStream on: aString) asOrderedCollection.! !!MySTCompiler methodsFor: 'as yet unclassified' stamp: 'SZ 1/30/2008 21:04'!collectExpressions: aSourceString	| newString |	newString := aSourceString.	newString isEmpty 		ifTrue: [^self].	[newString first = '.' | ((self whoIs: newString first) = #comment)]		whileTrue: [			newString := newString copyWithoutFirst. 			newString ifEmpty: [^self].].	expressions add: (MySTExpression newFrom: newString) first.	newString := newString copyFrom: expressions last size + 1 to: newString size.		^self collectExpressions: newString.! !!MySTCompiler methodsFor: 'as yet unclassified' stamp: 'SZ 12/31/2007 16:34'!error: aString	self error: aString with: self.!]style[(7 7 33)f2b,f2cblue;b,f2! !!MySTCompiler methodsFor: 'as yet unclassified' stamp: 'SZ 12/31/2007 16:08'!error: aString with: aObject	"error!!!!!!"	aString inspect.	self halt.! !!MySTCompiler methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 20:11'!whoIs: anObject	(anObject isKindOf: MySTExpression) 		ifFalse: [^MySTLexicalAnalyzerStream whatType: anObject] 		ifTrue: [^anObject whatType].! !!MySTCompiler methodsFor: 'evaluating' stamp: 'SZ 1/31/2008 19:10'!compile	expressions do: [:expr | expr compileIn: self].	postcompileList do: [:obj| obj value: self].	^self.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/31/2008 19:04'!addPostCompile: aObject	postcompileList add: aObject.	^self.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/5/2008 12:48'!assign: aMySTExpressionObject to: aMySTExpressionObject2 	self addInstruction: #LD target: aMySTExpressionObject2 where source: aMySTExpressionObject where.	aMySTExpressionObject where: aMySTExpressionObject2 where.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/4/2008 18:52'!callPrimitive: aInteger result: aMySTExpression	self freeReturnedObj.	self addInstruction: #CALL target: #literals->aInteger.		returnedObj _ aMySTExpression.	aMySTExpression where: #returnedobj->nil.	self clearArguments.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/4/2008 18:54'!callPrimitive: aInteger withArgs: anOrderedCollection result: aMySTExpression	self freeReturnedObj.	anOrderedCollection 		ifNotNil: [			self freeArguments.			anOrderedCollection withIndexDo: [:arg :num| self copyToArguments: arg position: num - 1.]].			self addInstruction: #CALL target: #literals->aInteger.		returnedObj _ aMySTExpression.	aMySTExpression where: #returnedobj->nil.	self clearArguments.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/30/2008 20:39'!clearArguments	arguments _ Array new..! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:25'!clearReturnedObj	returnedObj _ nil.		! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/13/2008 19:15'!copyToArguments: aMySTExpression position: aInteger 	self addInstruction: #LD target: #arguments->aInteger source: aMySTExpression where.	arguments size < (aInteger+1)		ifTrue: [arguments _ arguments , (Array new: arguments size - aInteger + 1)].	arguments at: aInteger +1 put: aMySTExpression.	"aMySTExpression where: #arguments->aInteger."! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/4/2008 12:24'!copyToInstances: aMySTExpression position: aInteger 	instances size - 1 < aInteger 		ifTrue: [self error: 'instance out of range!!'. ^nil].			self addInstruction: #LD target: #instancess->aInteger source: aMySTExpression where.	instances at: aInteger +1 put: aMySTExpression.	aMySTExpression where: #instances->aInteger.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/4/2008 12:48'!copyToReturnedObj: aMySTExpression	aMySTExpression where = (#returnedobj->nil)		ifFalse: [self addInstruction: #LD target: #returnedobj->nil source: aMySTExpression where.			aMySTExpression where: #returnedobj->nil.]! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:12'!copyToTemps: aMySTExpression position: aInteger 	self addInstruction: #LD target: #temps->aInteger source: aMySTExpression where.	temps size < (aInteger+1)		ifTrue: [temps _ temps , (Array new: temps size - aInteger + 1)].	temps at: aInteger +1 put: aMySTExpression.	aMySTExpression where: #temps->aInteger.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/24/2008 13:33'!findVariableByName: aString ifAbsent: aBlock	arguments do: [:arg | arg value = aString ifTrue: [^arg]].	"from end to start for not unique block arg name"	(Interval from: temps size to: 1 by: -1) do: [:index | (temps at: index) value = aString ifTrue: [^temps at: index]].	instances do: [:inst | inst value = aString ifTrue: [^inst]].	"literals do: [:lit | lit value = aString ifTrue: [^lit]]."	^aBlock value.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/4/2008 18:33'!freeArguments	arguments do: [:arg | 		arg ifNotNil:[			self copyToTemps: arg position: temps size.]].	arguments _ Array new: arguments size.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/4/2008 18:33'!freeReturnedObj	returnedObj 		ifNotNil: [			returnedObj where = (#returnedobj->nil)				ifTrue: [					self copyToTemps: returnedObj position: temps size. returnedObj := nil.]].	returnedObj _ nil.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/4/2008 12:34'!freeReturnedObjExcept: aMySTExpression 	aMySTExpression where = (#returnedobj->nil)		ifTrue: [^self]		ifFalse: [^self freeReturnedObj].! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/4/2008 13:15'!return: aMySTExpression	self addInstruction: #RET target: aMySTExpression where.	"aMySTExpression where: #returnedobj->nil."! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 2/5/2008 12:38'!send: aMySTExpressionLiteral to: aMySTExpressionObject withArgs: anOrderedCollection result: aMySTExpressionCall	self freeReturnedObj.	self freeArguments.	anOrderedCollection 		ifNotNil:[anOrderedCollection 			withIndexDo: [:arg :num| self copyToArguments: arg position: num - 1.]].			self addInstruction: #SM 		target: aMySTExpressionObject where 		source: aMySTExpressionLiteral where.			returnedObj _ aMySTExpressionCall.	aMySTExpressionCall where: #returnedobj -> nil.	self clearArguments.! !!MySTCompiler methodsFor: 'accessing' stamp: 'SZ 1/21/2008 20:46'!bytecode	^bytecode asArray.! !!MySTCompiler methodsFor: 'accessing' stamp: 'SZ 1/31/2008 19:54'!instances	^instances.! !!MySTCompiler methodsFor: 'accessing' stamp: 'SZ 1/28/2008 17:57'!literals	^literals	! !!MySTCompiler methodsFor: 'accessing' stamp: 'SZ 1/28/2008 17:57'!temps	^temps	! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/28/2008 17:42'!addArgument: aMySTExpressionObject 	arguments _ arguments , (Array with: aMySTExpressionObject).	aMySTExpressionObject where: #arguments->(arguments size - 1)! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/30/2008 18:33'!addInstance: aMySTExpressionObject 	instances _ instances , (Array with: aMySTExpressionObject).	aMySTExpressionObject where: #instances->(instances size - 1)! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/23/2008 15:21'!addInstruction: aSymbol target: anAssociation 	self addInstruction: aSymbol target: anAssociation source: #self->0.! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/23/2008 15:19'!addInstruction: cmd target: trg source: src	|  cmdbyte trgbyte srcbyte |	"cmd"	cmd = #CALL ifTrue: [cmdbyte _ 0].	cmd = #LD ifTrue: [cmdbyte _ 64].	cmd = #SM ifTrue: [cmdbyte _ 128].	cmd = #RET ifTrue: [cmdbyte _ 192].			"trg"	"trg key = #self ifTrue: [cmdbyte _ cmdbyte]."	trg key = #super ifTrue: [cmdbyte _ cmdbyte + 8].	trg key = #returnedobj ifTrue: [cmdbyte _ cmdbyte + 16].	"trg key = #none ifTrue: [cmdbyte _ cmdbyte + 24]."	trg key = #literals ifTrue: [cmdbyte _ cmdbyte + 32. trgbyte _ trg value].	trg key = #temps ifTrue: [cmdbyte _ cmdbyte + 40. trgbyte _ trg value].	trg key = #arguments ifTrue: [cmdbyte _ cmdbyte + 48. trgbyte _ trg value].	trg key = #instances ifTrue: [cmdbyte _ cmdbyte + 56. trgbyte _ trg value].	"src"	"src key = #self ifTrue: [cmdbyte _ cmdbyte + 0]."	src key = #super ifTrue: [cmdbyte _ cmdbyte + 1].	src key = #returnedobj ifTrue: [cmdbyte _ cmdbyte + 2].	"src key = #none ifTrue: [cmdbyte _ cmdbyte + 3]."	src key = #literals ifTrue: [cmdbyte _ cmdbyte + 4. srcbyte _ src value].	src key = #temps ifTrue: [cmdbyte _ cmdbyte + 5. srcbyte _ src value].	src key = #arguments ifTrue: [cmdbyte _ cmdbyte + 6. srcbyte _ src value].	src key = #instances ifTrue: [cmdbyte _ cmdbyte + 7. srcbyte _ src value].	bytecode add: cmdbyte.	trgbyte ifNotNil: [bytecode add: trgbyte].	srcbyte ifNotNil: [bytecode add: srcbyte].		^self! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/23/2008 16:25'!addLiteral: aMySTExpressionObject 	literals add: aMySTExpressionObject.	aMySTExpressionObject where: #literals->(literals size - 1)! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/25/2008 17:10'!addTemp: aMySTExpressionObject 	temps _ temps , (Array with: aMySTExpressionObject).	aMySTExpressionObject where: #temps -> (temps size - 1).	"self addTemp: aMySTExpressionObject position: temps size."! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 2/2/2008 11:49'!expressions: anOrderedCollection 	expressions _ anOrderedCollection.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTCompiler class	instanceVariableNames: ''!!MySTCompiler class methodsFor: 'as yet unclassified' stamp: 'SZ 1/30/2008 18:43'!currentGlobalDictionary	^CurrentGlobalDictionary ! !!MySTCompiler class methodsFor: 'as yet unclassified' stamp: 'SZ 1/30/2008 18:27'!currentGlobalDictionary: aDictionary	CurrentGlobalDictionary _ aDictionary.! !!MySTCompiler class methodsFor: 'as yet unclassified' stamp: 'SZ 2/2/2008 12:30'!newFrom: anObject	"anObject - aString (MySTCompiler) or aMySTSourceTextMethod/Block (MySTCompiledMethod/Block)"	^self new initializeFrom: anObject; compile.! !!MySTCompiler class methodsFor: 'instance creation' stamp: 'SZ 1/10/2008 15:28'!compile: aString 	^ super new initializeWith: aString; compile.!]style[(9 7 5 5 21 17)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !MySTCompiler subclass: #MySTCompiledBlock	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Compiler'!!MySTCompiledBlock methodsFor: 'compiling' stamp: 'SZ 2/2/2008 12:38'!compile	"We compiling in the end"	^self.! !!MySTCompiledBlock methodsFor: 'compiling' stamp: 'SZ 2/4/2008 12:53'!compile: aMySTCompiler	temps _ aMySTCompiler temps.	instances _ aMySTCompiler instances.	super compile.	expressions size = 0		ifFalse: [expressions last where = (#returnedobj->nil)					ifFalse: [^self copyToReturnedObj: expressions last]].! !!MySTCompiledBlock methodsFor: 'as yet unclassified' stamp: 'SZ 2/2/2008 12:35'!initializeFrom: aMySTExpressionBlock 	self expressions: aMySTExpressionBlock expressions.	aMySTExpressionBlock arguments do: [:blockarg| self addArgument: blockarg]..	^self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTCompiledBlock class	instanceVariableNames: ''!!MySTCompiledBlock class methodsFor: 'as yet unclassified' stamp: 'SZ 2/2/2008 12:37'!compile	^nil.! !MySTCompiler subclass: #MySTCompiledMethod	instanceVariableNames: 'sourcemethod'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Compiler'!!MySTCompiledMethod methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 12:10'!initializeFrom: aMySTSourceTextMethod 		sourcemethod _ aMySTSourceTextMethod.	self expressions: sourcemethod expressions.	aMySTSourceTextMethod arguments do: [:arg | self addArgument: arg].	globalDict ifNotNil: [		(globalDict at: sourcemethod forClass) instances 			do: [:instvar| self addInstance: (MySTExpressionObject withName: instvar)]].	^self.! !!MySTCompiledMethod methodsFor: 'accessing' stamp: 'SZ 2/10/2008 17:14'!argCount	^sourcemethod arguments size.! !!MySTCompiledMethod methodsFor: 'accessing' stamp: 'SZ 1/28/2008 18:01'!arguments	^sourcemethod arguments.! !!MySTCompiledMethod methodsFor: 'accessing' stamp: 'SZ 2/9/2008 11:45'!forClass	^sourcemethod forClass.! !!MySTCompiledMethod methodsFor: 'accessing' stamp: 'SZ 2/10/2008 17:18'!inTheClass	^sourcemethod forClass.! !!MySTCompiledMethod methodsFor: 'accessing' stamp: 'SZ 2/4/2008 13:25'!message	^sourcemethod message.! !!MySTCompiledMethod methodsFor: 'accessing' stamp: 'SZ 2/10/2008 17:16'!tmpCount	^temps size.! !TestCase subclass: #MySTCompilerTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Compiler'!!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 11:38'!setUp	MySTCompiler currentGlobalDictionary: nil.! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 12:51'!testBlock1"bytecode in block ???"	| code |	code _ MySTCompiler compile: '[:a | a]'.	self should: code bytecode = #(116 0 0 32 9 ).	self should: code literals size = 1.	self should: (code literals first isKindOf: MySTExpressionBlock).	self should: code literals first bytecode = #(86 0).	self should: code literals first arguments size = 1.	self should: code literals first temps size = 0.! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 19:16'!testBlock2	| code |	code _ MySTCompiler compile: '[:a|] value: 1'.	self should: (code bytecode = #(116 0 0 32 9 116 0 2 148 1 ) | (code bytecode = #(116 0 0 32 9 106 0 116 0 2 172 0 1))).	self should: code literals size = 3.	self should: code literals second value = 'value:'.	self should: code literals third value = '1'.	self should: (code literals first isKindOf: MySTExpressionBlock).	self should: code literals first bytecode size = 0.	self should: code literals first literals size = 0."	self should: code literals first argCount = 1.	self should: code literals first temps size = 0."	! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/5/2008 12:40'!testBlock3	| code |	code := MySTCompiler compile: '[:a | a asInteger] value: 1'.	self should: code bytecode = #(116 0 0 32 9 116 0 2 148 1 ) | (code bytecode = #(116 0 0 32 9 106 0 116 0 2 172 0 1)).	self should: code literals size = 3.	self should: code literals second value = 'value:'.	self should: code literals third value = '1'.	self should: (code literals first isKindOf: MySTExpressionBlock).	self should: code literals first bytecode = #(180 0 0 ) | (code literals first bytecode =  #(110 1 0 172 1 0)).	self should: code literals first literals size = 1 & (code literals first literals first value = 'asInteger')."	self should: code literals first argCount = 1.	self should: code literals first tmpCount = 0."! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 13:01'!testBlock4	| code |	code _ MySTCompiler compile: '[:a :b| a+b] value: 1 value: 2'.	self should: code bytecode = #(116 0 0 32 9 116 0 1 116 1 2 148 3 ) | (code bytecode = #(116 0 0 32 9 106 0 116 0 2 116 1 3 172 0 1)).	self should: code literals size = 4.	self should: (code literals at: 2) value = 'value:value:'.	self should: (code literals at: 3) value = '1'.	self should: (code literals at: 4) value = '2'.	self should: (code literals first isKindOf: MySTExpressionBlock).	self should: code literals first bytecode = #(110 1 0 110 2 1 117 0 2 172 1 0).	self should: code literals first literals size = 1.	self should: code literals first literals first value = '+'.	self should: code literals first arguments size = 2.	"self should: code literals first temps size = 0."! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 19:22'!testBlock5	| code block1 |	code _ MySTCompiler compile: '[:a :abc :bcd :hjk| abc at: 1 put: 2. ^hjk] value: 1.'.	self should: code bytecode = #(116 0 0 32 9 116 0 2 148 1 ) | (code bytecode = #(116 0 0 32 9 106 0 116 0 2 172 0 1)).	self should: code literals size = 3.	self should: code literals second value = 'value:'.	self should: code literals third value = '1'.	block1 _ code literals first."	self should: block1 isBlock."	self should: block1 bytecode = #(110 1 0 110 2 1 110 3 2 110 4 3 116 0 1 116 1 2 172 2 0 232 4) | (block1 bytecode = #(110 0 0 110 1 1 110 2 2 110 3 3 116 0 1 116 1 2 172 1 0 232 3)).	self should: block1 literals size = 3.	self should: block1 literals first value = 'at:put:'.	self should: block1 literals second value = '1'.	self should: block1 literals third value = '2'.	self should: block1 arguments size = 4."	self should: block1 tmpCount = 0."! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 13:17'!testBlock6	"bytecode in testBlock1 ???"	| code |	code _ MySTCompiler compile: '^[1] value'.	self should: code bytecode = #(116 0 0 32 9 148 1 208 ) | (code bytecode =  #(116 0 0 32 9 106 0 172 0 1 208)).	self should: code literals size = 2."	self should: code literals first isBlock."	self should: code literals first bytecode = #(84 0 ).	self should: code literals first literals size = 1.	self should: code literals first literals first value = '1'.	self should: code literals first arguments size = 0."	self should: code literals first tmpCount = 0."! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 18:56'!testBlock7	"direct method compiling DISABLED!!"	| code block1 |	code _ MySTCompiler compile: '[:a| a=0 ifTrue: [3]].'.	self should: code bytecode = #(116 0 0 32 9).	self should: code literals size = 1.	block1 _ code literals first."	self should: block1 isBlock."	self should: block1 bytecode = #(116 0 1 172 0 0 106 1 116 0 3 32 9 114 0 172 1 2) | (block1 bytecode =  #(110 0 0 116 0 1 172 0 0 106 1 116 0 3 32 9 106 2 117 0 2 172 1 2)).	self should: block1 literals size = 4.	self should: block1 literals first value = '='.	self should: block1 literals second value = '0'.	self should: block1 literals third value = 'ifTrue:'."	self should: (block1 literals at: 4) isBlock."! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/5/2008 12:24'!testBlock8	| code block1 |	code := MySTCompiler compile: '[a at: 1+1 put: ''123'' size+1*4]'.	self should: code bytecode = #(116 0 0 32 9).	self should: code literals size = 1.	block1 _ code literals first."	self should: block1 isBlock."	self should: block1 bytecode = #(164 0 1 106 0 116 0 5 164 3 4 106 1 164 6 7 106 2 116 0 9 172 2 8 106 3116 0 11 172 3 10 106 4 117 0 1 117 1 4 172 0 2).	self should: block1 literals size = 12.	self should: block1 literals first value = 'a'.	self should: (block1 literals at: 2) value = 'value'.	self should: (block1 literals at: 3) value = 'at:put:'.	self should: (block1 literals at: 4) value = '1'.	self should: (block1 literals at: 5) value = '+'.	self should: (block1 literals at: 6) value = '1'.	self should: (block1 literals at: 7) value = '123'.	self should: (block1 literals at: 8) value = 'size'.	self should: (block1 literals at: 9) value = '+'.	self should: (block1 literals at: 10) value = '1'.	self should: (block1 literals at: 11) value = '*'.	self should: (block1 literals at: 12) value = '4'."	self should: block1 temps size = 2."	self should: block1 arguments size = 0.! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/5/2008 12:31'!testBlock9	"direct method compiling DISABLED!!"	| code block1 block2 block3 |	code := (MySTSourceTextMethod newFrom: 'skipTo: anObject [ self atEnd ] whileFalse: [		self next = anObject ifTrue: [ ^true ]].	^false') asCompiledMethod."	self should: code isMethod."	self should: code message = 'skipTo:'.	self should: code bytecode = #(110 0 0 116 0 0 32 9 106 1 116 0 2 32 9 106 2 117 0 2 172 1 1 106 3 164 3 4 208).	self should: code literals size = 5.	block1 _ code literals first."	self should: block1 isBlock."	self should: block1 bytecode = #(132 0 ).	self should: block1 literals size = 1.	self should: block1 literals first value = 'atEnd'.	block2 _ code literals third."	self should: block2 isBlock."	self should: block2 literals size = 4.	self should: (block2 literals at: 1) value = 'next'.	self should: (block2 literals at: 2) value = '='.	self should: (block2 literals at: 3) value = 'ifTrue:'.	self should: block2 bytecode = #(132 0 106 4 117 0 0 172 4 1 106 5116 0 3 32 9 106 6117 0 6 172 5 2).	block3 _ block2 literals at: 4."	self should: block3 isBlock."	self should: block3 bytecode = #(164 0 1 208 ).	self should: block3 literals size = 2.	self should: (block3 literals at: 1) value = 'true'.	self should: (block3 literals at: 2) value = 'value'.! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/5/2008 12:14'!testCascadeCall	| test |	test _ MySTCompiler compile: '1 clone; + 1; asString'.	self should: (test bytecode = #(164 0 1 116 0 3 164 0 2 164 0 4) | (test bytecode = #(164 2 1 116 0 4 164 2 3 164 2 0))).		test _ MySTCompiler compile: '''123'' asByteArray at: 1 put: 63 ; at: 2 set:56;at:3 replace:78; printOn: Transcript.'.	self should: [test bytecode = #(164 0 1 106 0 116 0 3 116 1 4 172 0 2 116 0 6 116 1 7 172 0 5 116 0 9 116 1 10 172 0 8 164 12 13 106 1 117 0 1 172 0 11)].! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/30/2008 20:37'!testCode1	| code test |	test := MySTSourceTextMethod newFrom: 'arg1: arg1 arg2: arg2	^arg1 + arg2!!'.	self should: (test isKindOf: MySTSourceTextMethod).	code _ test asCompiledMethod.	self should: code temps size = 2.	self should: code literals size = 1.	self should: code literals first value = '+'.	self should: code arguments size = 2.	self should: code bytecode = #(110 0 0 110 1 1 117 0 1 172 0 0 208).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/18/2008 15:24'!testCode2	| code test |	test := MySTSourceTextMethod newFrom: '= aSmallInt	^self == aSmallInt asSmallInteger.!!'.	self should: (test isKindOf: MySTSourceTextMethod).	code _ test asCompiledMethod.	self should: code temps size = 2.	self should: code literals size = 2.	self should: code literals first value = '=='.	self should: code literals second value = 'asSmallInteger'.	self should: code arguments size = 1.	self should: (code bytecode = #(110 0 0 172 0 1 114 0 132 0 208)) | (code bytecode = #(110 0 0 172 0 1 106 1 117 0 1 132 0 208)).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/5/2008 12:35'!testCode3	| code block1 |	code := (MySTSourceTextMethod newFrom: ' new ^(Interval newFrom: 1 to: 3 step: 1) do: [:item| <primitive: 112> value: item].!!') asCompiledMethod.	self should: code arguments size = 0."	self should: code temps size = 1."	self should: code literals size = 8.	self should: (code literals at: 1) value = 'Interval'.	self should: (code literals at: 2) value = 'value'.	self should: (code literals at: 3) value = 'newFrom:to:step:'.	self should: (code literals at: 4) value = '1'.	self should: (code literals at: 5) value = '3'.	self should: (code literals at: 6) value = '1'.	self should: (code literals at: 7) value = 'do:'."	self should: (code literals at: 8) isBlock."	self should: code bytecode = #(164 0 1 106 0 116 0 3 116 1 4 116 2 5 172 0 2 106 1 116 0 7 32 9 114 0 172 1 6 208) | (code bytecode =  #(164 0 1 106 0 116 0 3 116 1 4 116 2 5 172 0 2 106 1116 0 7 32 9 106 2 117 0 2 172 1 6 208)).	block1 := code literals at: 8.	self should: block1 arguments size = 1.	self should: block1 literals size = 0.	self should: block1 bytecode = #(117 0 1 32 112) | (block1 bytecode = #(110 3 0 117 0 3 32 112)).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/5/2008 13:01'!testCode4	"at: zamenit na poisk na prisutstvii (?)	tmps: 	0 - arg1	1 - arg2	2 - arg3	3 - temp	4 - flag	5 - method: temp1	6 - block1: temp1	7 - block1: temp2"	| test lits block1 block2 block3 |	test := MySTSourceTextMethod newFrom: 'arg1: arg1 arg2: arg2 arg3: arg3	| temp flag |	temp := Bag new.	temp add: arg1.	temp count = 1 ifTrue: [(temp count = 2) ifTrue: [temp add: arg3. ^temp] ifFalse: [temp add: arg2]. flag := true.]	^ nil !!'.	self should: (test isKindOf: MySTSourceTextMethod)."	self should: test isMethod."	self should: test arguments size = 3.	self should: (test arguments first value = 'arg1') 		& (test arguments second value = 'arg2')		& (test arguments third value =  'arg3').	self should: test message = 'arg1:arg2:arg3:'.	test _ test asCompiledMethod."	self should: test temps size = 2.	self should: test temps = #('temp' 'flag' )."	lits := test literals.	self should: lits size = 11.	self should: (lits at: 1) value = 'Bag'.	self should: (lits at: 2) value = 'value'.	self should: (lits at: 3) value = 'new'.	self should: (lits at: 4) value = 'add:'.	self should: (lits at: 5) value = 'count'.	self should: (lits at: 6) value = '='.	self should: (lits at: 7) value = '1'.	self should: (lits at: 8) value = 'ifTrue:'."	self should: (lits at: 9) isBlock."	self should: (lits at: 10) value = 'nil'.	self should: (lits at: 11) value = 'value'.	self should: test bytecode = #(110 2 0 110 3 1 110 4 2164 0 1 106 5 172 5 2 106 0 117 0 2 172 0 3 106 6172 0 4 106 7 116 0 6 172 7 5 106 8 116 0 8 32 9 106 9 117 0 9 172 8 7 106 10 164 9 10 208).	block1 := lits at: 9."	self should: block1 temps size = 0."	self should: block1 arguments size = 0.	self should: block1 literals size = 8.	self should: (block1 literals at: 1) value = 'count'.	self should: (block1 literals at: 2) value = '='.	self should: (block1 literals at: 3) value = '2'.	self should: (block1 literals at: 4) value = 'ifTrue:ifFalse:'."	self should: (block1 literals at: 5) isBlock.	self should: (block1 literals at: 6) isBlock."	self should: (block1 literals at: 7) value = 'true'.	self should: (block1 literals at: 8) value = 'value'.	self should: block1 bytecode = #(172 0 0 106 11 116 0 2 172 11 1 106 12 116 0 4 32 9 106 13 116 0 5 32 9 106 14 117 0 13 117 1 14 172 12 3 106 15 164 6 7 106 1 85 1).	block2 := block1 literals at: 5.	self should: block2 literals size = 1.	self should: (block2 literals at: 1) value = 'add:'.	self should: block2 bytecode = #(117 0 4 172 0 0 232 0).	block3 := block1 literals at: 6.	self should: block3 literals size = 1.	self should: (block3 literals at: 1) value = 'add:'.	self should: block3 bytecode = #(117 0 3 172 0 0).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/5/2008 20:30'!testCode5	| code |	code := (MySTSourceTextMethod newFrom: 'startingAt: t1 match: t2 startingAt: t3 | t4 t5 t6 t7 t8 t9 t10 t11 |	t7 := t1.	t9 := t3.	[t7 > self size ifTrue: [^ t9 > t2 size].	(self at: t7)	= $#]		whileTrue: [t9 > t2 size ifTrue: [^ false].	t7 := t7 + 1. t9 := t9 + 1].	(self at: t7)	= $*		ifTrue: [t7 = self size ifTrue: [^ true]. t4 := true.	t5 := t7 + 1]		ifFalse: [t4 := false. t5 := t7].	t6 := self size.	(t10 := self indexOf: $* startingAt: t5) > 0		ifTrue: [t10 = 1 ifTrue: [self error: ''** not valid -- use * instead'']. t6 := t10 - 1].	(t10 := self indexOf: $# startingAt: t5) > 0		ifTrue: [t10 = 1 ifTrue: [self error: ''*# not valid -- use #* instead'']. t6 := t6 min: t10 - 1].	t8 := self copyFrom: t5 to: t6.	[t11 := t2 findString: t8 startingAt: t9 caseSensitive: false. t4 ifTrue: [t11 > 0] ifFalse: [t11 = t9]]		whileTrue: [(self startingAt: t6 + 1 match: t2 startingAt: t11 + t8 size) ifTrue: [^ true]. t4 ifFalse: [^ false]. t9 := t9 + 1].	^ false') asCompiledMethod.	self should: code literals size = 28.	self should: ((code literals at: 1) isKindOf: MySTExpressionBlock).	self should: (code literals at: 2) value = 'whileTrue:'.	self should: ((code literals at: 3) isKindOf: MySTExpressionBlock).	self should: (code literals at: 4) value = 'at:'.	self should: (code literals at: 5) value = '='.	self should: (code literals at: 6) value = '$*'.	self should: (code literals at: 7) value = 'ifTrue:ifFalse:'.	self should: ((code literals at: 8) isKindOf: MySTExpressionBlock).	self should: ((code literals at: 9) isKindOf: MySTExpressionBlock).	self should: (code literals at: 10) value = 'size'.	self should: (code literals at: 11) value = 'indexOf:startingAt:'.	self should: (code literals at: 12) value = '$*'.	self should: (code literals at: 13) value = '>'.	self should: (code literals at: 14) value = '0'.	self should: (code literals at: 15) value = 'ifTrue:'.	self should: ((code literals at: 16) isKindOf: MySTExpressionBlock).	self should: (code literals at: 17) value = 'indexOf:startingAt:'.	self should: (code literals at: 18) value = '$#'.	self should: (code literals at: 19) value = '>'.	self should: (code literals at: 20) value = '0'.	self should: (code literals at: 21) value = 'ifTrue:'.	self should: ((code literals at: 22) isKindOf: MySTExpressionBlock).	self should: (code literals at: 23) value = 'copyFrom:to:'.	self should: ((code literals at: 24) isKindOf: MySTExpressionBlock).	self should: (code literals at: 25) value = 'whileTrue:'.	self should: ((code literals at: 26) isKindOf: MySTExpressionBlock).	self should: (code literals at: 27) value = 'false'.	self should: (code literals at: 28) value = 'value'.	self should: code bytecode = #(110 3 0110 5 2 110 8 0 110 9 1 110 10 2 116 0 0 32 9 106 11 116 0 2 32 9 106 12 117 0 12 172 11 1 106 13 117 0 3 132 3 106 14 116 0 5 172 14 4 106 15 116 0 7 32 9 106 16 116 0 8 32 9 106 17 117 0 16 117 1 17 172 15 6 106 18 132 9 106 2 116 0 11 117 1 1 132 10 106 6 116 0 13 172 6 12 106 19 116 0 15 32 9 106 20 117 0 20 172 19 14 106 21 116 0 17 117 1 1 132 16 106 6 116 0 19 172 6 18 106 22 116 0 21 32 9 106 23 117 0 23 172 22 20 106 24 117 0 1 117 1 2 132 22 106 4 116 0 23 32 9 106 25 116 0 25 32 9 106 26 117 0 26 172 25 24 106 27 164 26 27 208).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/18/2008 15:44'!testCode6	| code |	code := (MySTSourceTextMethod newFrom: 'asSmallInteger	self > (0 - 127) ifTrue: [(self < 128) ifTrue: [^self basicAt: 1] ifFalse: [^nil]].!!') asCompiledMethod.	self should: code literals size = 6.	self should: ((code literals at: 1) value = '>').	self should: (code literals at: 2) value = '0'.	self should: ((code literals at: 3) value = '-').	self should: (code literals at: 4) value = '127'.	self should: (code literals at: 5) value = 'ifTrue:'.	self should: ((code literals at: 6) isKindOf: MySTExpressionBlock).	self should: code bytecode = #(116 0 3 164 1 2 106 0 117 0 0 132 0 106 1 116 0 5 32 9 106 2 117 0 2 172 1 4).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/21/2008 19:14'!testCode7	"negativ or - and number!!"	| code block1 block2 |	code := (MySTSourceTextMethod newFrom: 'test_Block10	| i |	i := 10.	[i > 0] whileTrue: [ i := i - 1].	^i.!!') asCompiledMethod.	self should: code literals size = 4.	self should: ((code literals at: 1) value = '10').	self should: ((code literals at: 2)  isKindOf: MySTExpressionBlock).	self should: ((code literals at: 3) value = 'whileTrue:').	self should: ((code literals at: 4) isKindOf: MySTExpressionBlock).	self should: code bytecode = #(108 0 0 116 0 1 32 9 106 1 116 0 3 32 9 106 2 117 0 2 172 1 2 232 0 ).	block1 _ code literals at: 2.	self should: block1 literals size = 2.	self should: block1 literals first value = '>'.	self should: block1 literals second value = '0'.	self should: block1 bytecode = #(116 0 1 172 0 0).	block2 _ code literals at: 4.	self should: block2 literals size = 2.	self should: block2 literals first value = '-'.	self should: block2 literals second value = '1'.	self should: block2 bytecode = #(116 0 1 172 0 0 106 0 85 0).	! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 11:37'!testMethodAsPointer	| test |	test _ MySTSourceTextMethod newFrom: 'asPointer
	| meAsPointer |
	meAsPointer := <primitive: 32> value: self.
	meAsPointer isMagnitude ifTrue: [meAsPointer class: Pointer].
	^meAsPointer.!!
'.	self shouldnt: test message = '|'.	self should: test message = 'asPointer'.	! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:18'!testPrim	self		should: (MySTCompiler compile: '<primitive: 1> value') bytecode = #(32 1)! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:38'!testPrim2	self		should: (MySTCompiler compile: '^<primitive: 5> value: 1 value: 0') bytecode = #(116 0 0 116 1 1 32 5 208).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 16:09'!testRetGlobalLiteral	self		should: [(MySTCompiler compile: '^Object') bytecode = #(164 0 1 208)]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 15:38'!testRetSMBinResult	self		should: [(MySTCompiler compile: '^1 + 1') bytecode = #(116 0 2 164 0 1 208)]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/5/2008 12:11'!testRetSMKeyResult	| result |		result _ MySTCompiler compile: '^$. new: 1'.	self should: (result bytecode = #(116 0 2 164 0 1 208)) | (result bytecode = #(116 0 1 164 2 0 208)).		result _ MySTCompiler compile: '^''123'' at: 1 put: 63.'.	self should: (result bytecode = #(116 0 1 116 1 2 164 3 0 208) | (result bytecode = #(116 0 2 116 1 3 164 0 1 208))).		result _ MySTCompiler compile: '^''123'' printOn: Transcript.'.	self should: (result bytecode = #(164 2 3 114 0 164 0 1 208) | (result bytecode = #(164 2 3 106 0 117 0 0 164 0 1 208))).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:25'!testRetSMUnoResult1	| test |	test _ MySTCompiler compile: '^1 asString'.	self should: (test bytecode = #(164 0 1 208)) | (test bytecode = #(164 1 0 208)).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:59'!testRetSelf	self		should: [(MySTCompiler compile: '^self') bytecode = #(192 )]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:57'!testRetSuper	self		should: [(MySTCompiler compile: '^super') bytecode = #(200 )]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:25'!testRetTmp	self		should: [(MySTCompiler compile: '| var1 | ^var1') bytecode = #(232 0 )]! !Object subclass: #MySTFileIn	instanceVariableNames: 'file parsedSourceText classes'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Compiler'!!MySTFileIn methodsFor: 'as yet unclassified' stamp: 'SZ 3/2/2008 17:42'!asNewImage	| image |	image _ MySTImage new createStartClasses.	classes createValueMethodForSymbolClass.	classes createValueMethodsForBlockClass.	"classes createDoRelocationMethodForObjectClass."	classes addToImage: image.	^image.	! !!MySTFileIn methodsFor: 'as yet unclassified' stamp: 'SZ 2/7/2008 20:39'!fromFile: aFilePath	file _ (FileStream fileNamed: aFilePath).	^self.! !!MySTFileIn methodsFor: 'as yet unclassified' stamp: 'SZ 2/7/2008 20:41'!getSourceText	| srcText |	srcText _ file contents.	^MySTSourceText newFrom: srcText.! !!MySTFileIn methodsFor: 'as yet unclassified' stamp: 'SZ 2/7/2008 21:53'!parse	| srcText temp |	srcText _ file contents.	parsedSourceText _ OrderedCollection new.	[temp _ (MySTSourceText newFrom: srcText).	(temp isKindOf: MySTSourceTextCode) 		ifTrue: [self halt.]		ifFalse: [parsedSourceText add: temp.			srcText _ (srcText allButFirst: parsedSourceText last size) withoutLeadingBlanks].	srcText = '']		whileFalse.	^self.! !!MySTFileIn methodsFor: 'compiling' stamp: 'SZ 2/9/2008 15:55'!compile	classes _ MySTGlobalDictionary new.	MySTCompiler currentGlobalDictionary: classes.	parsedSourceText do: [:each | 		(each isMemberOf: MySTSourceTextClass)			ifTrue: [classes addClass: each className						superClass: each classSuperName						instanceVariableNames: each instanceVariableNames						classVariableNames: each classVariableNames].		(each isMemberOf: MySTSourceTextClassMethods)			ifTrue: [each methods 						do: [:meth | 							classes 								addMethod: meth asCompiledMethod 								toClass: meth forClass]].		(each isMemberOf: MySTSourceTextMethods)			ifTrue: [each methods 						do: [:meth | 							classes 								addMethod: meth asCompiledMethod								toClass: meth forClass]].							].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTFileIn class	instanceVariableNames: ''!!MySTFileIn class methodsFor: 'as yet unclassified' stamp: 'SZ 2/7/2008 20:38'!fromFile: aString	^super new fromFile: aString.! !