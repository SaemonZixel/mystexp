Stream subclass: #MySTLexicalAnalyzerStream	instanceVariableNames: 'sourcetext errormode lasttoken'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTLexicalAnalyzerStream methodsFor: 'initialize-release' stamp: 'SZ 1/2/2008 21:39'!initialize: aString 	sourcetext := ReadStream on: aString.	errormode := false.!]style[(12 7 3 10 19 29)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:23'!nextTokenAsAssign	sourcetext next = $: & sourcetext atEnd not		ifTrue: [sourcetext peek = $=				ifTrue: [sourcetext next.					^ ':=' -> #assign]]		ifFalse: [sourcetext back].	^nil.!]style[(17 2 10 8 2 3 10 22 10 8 2 14 10 14 4 4 7 15 10 14)f2b,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:21'!nextTokenAsBinMess	| result |	result := ''.	[#($, $- $+ $\ $/ $* $~ $` $= $@ $% $& $? ${ $} $< $> $| ) includes: sourcetext peek]		whileTrue: [result := result , sourcetext next asString.			sourcetext atEnd				ifTrue: [^ result -> #binmessage]].	result = ''		ifTrue: [^ nil]		ifFalse: [^ result -> #binmessage]!]style[(18 3 7 4 6 4 2 4 57 42 6 4 6 64 6 4 11 5 6 3 2 14 3 16 6 4 11 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 2/4/2008 12:17'!nextTokenAsBlockArg	| result |	result _ ':'.	sourcetext next = $: & sourcetext atEnd not		ifTrue: [sourcetext peek isDigit					ifTrue: [self error: 'no digit in first letter of block arg name!!'. sourcetext next. ^ nil].									sourcetext peek isLetter | (sourcetext peek = $_) ifFalse: [sourcetext back. ^nil. "May be it is assign"].								[sourcetext atEnd not and: [sourcetext peek isAlphaNumeric | (sourcetext peek = $_)]]					whileTrue: [result _ result , sourcetext next asString].									result = ''					ifFalse: [^ result -> #blockarg]].	sourcetext back.	^ nil! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/23/2008 15:40'!nextTokenAsChar	sourcetext peek = '$' last		ifTrue: [sourcetext next.			sourcetext atEnd				ifTrue: [sourcetext back.					^ nil]				ifFalse: [^ ('$', sourcetext next asString) -> #char]].	^nil.! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 2/7/2008 22:02'!nextTokenAsComment	| result |	result := ''.	sourcetext peek = $" ifFalse: [^ nil].	sourcetext next.	[sourcetext atEnd ifTrue: [self error: 'comment can`t end here'. ^'"',result,'"' -> #comment].	sourcetext peek = $" ifTrue: [sourcetext next. ^'"',result,'"' -> #comment].	true]		whileTrue: [result := result , sourcetext next asString].	^ nil! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/26/2008 18:38'!nextTokenAsLiteralOrArray	| result |	result := ''.	sourcetext peek = $#		ifFalse: [^ nil].	sourcetext next.	sourcetext atEnd		ifTrue: [self error: 'literal can`t ending here!!'.			^ nil].	"take literal"	sourcetext peek isLetter		ifTrue: [[result := result , sourcetext next asString.			sourcetext peek isLetter | sourcetext peek isDigit] whileTrue.			^ '#',result -> #literal].	"take array"	sourcetext peek = $(		ifFalse: [self error: 'array no valid!!'.			^ nil].	[sourcetext atEnd		ifTrue: [self error: 'array no valid!!'.			^ nil].	result := result , sourcetext peek asString.	sourcetext next = $)] whileFalse.	sourcetext next.	^ '#',result -> #array! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/3/2008 11:19'!nextTokenAsNameOrKeymess	| result |	result := ''.	sourcetext peek isLetter | (sourcetext peek = $_)		ifTrue: [[sourcetext atEnd not				and: [sourcetext peek isAlphaNumeric | (sourcetext peek = $_)]]				whileTrue: [result := result , sourcetext next asString].			sourcetext peek = $:				ifTrue: [result := result , sourcetext next asString.					^ result -> #keymessage].			result ~= ''				ifTrue: [^ result -> #name]].	^ nil!]style[(24 3 7 4 6 4 2 3 10 18 10 8 2 14 10 21 10 24 10 8 2 20 6 4 6 3 10 20 10 8 2 14 6 4 6 3 10 23 6 4 11 6 6 4 2 16 6 4 5 7 3)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/3/2008 11:24'!nextTokenAsNumber	| result |	result := ''.	"take sign"	(sourcetext next = $- & sourcetext atEnd not			and: [sourcetext peek isDigit])		ifTrue: [result := '-']		ifFalse: [sourcetext back.			sourcetext peek isDigit				ifFalse: [^ nil]].	"take number"	[result := result , sourcetext next asString.	sourcetext atEnd		ifTrue: [^ result -> #number].	sourcetext peek isLetter		ifTrue: [self error: 'Letter in the end of number?'.			^ result -> #number].	sourcetext peek isDigit] whileTrue.	"take float part"	(sourcetext next = $. & sourcetext atEnd not			and: [sourcetext peek isDigit])		ifTrue: [result := result , '.'.			[result := result , sourcetext next asString.			sourcetext atEnd				ifTrue: [^ result -> #float].			sourcetext peek isLetter				ifTrue: [self error: 'Letter in the end of number?'.					^ result -> #float].			sourcetext peek isDigit] whileTrue.			^ result -> #float]		ifFalse: [sourcetext back].	^ result -> #number!]style[(17 3 7 4 6 4 2 3 11 3 10 8 2 3 10 20 10 27 6 4 3 14 10 10 10 30 3 5 13 3 6 4 6 3 10 17 10 20 6 4 7 4 10 26 4 8 30 7 6 4 7 4 10 27 17 3 10 8 2 3 10 20 10 27 6 4 6 3 3 6 6 4 6 3 10 19 10 22 6 4 6 6 10 28 4 8 30 9 6 4 6 6 10 31 6 4 6 14 10 11 6 4 7)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2c147045000,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c147045000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2c147045000,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/21/2008 20:59'!nextTokenAsPrimitive	| result |	result := ''.	sourcetext next = $< & sourcetext peek = $p		ifFalse: [sourcetext back.			^ nil].	[sourcetext atEnd		ifTrue: [self error: 'primitive can`t end here'.			^ nil].	sourcetext peek = $>]		whileFalse: [result := result , sourcetext next asString].	sourcetext next.	^ '<',result,'>' -> #primitive! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:26'!nextTokenAsSpecialToken	(#($!! $^ $; $. $[ $] $( $) $: $_ ) includes: sourcetext peek)		ifTrue: [^ sourcetext next asString -> #token]		ifFalse: [^nil].!]style[(23 3 33 11 10 20 10 18 6 20)f2b,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 2/7/2008 21:06'!nextTokenAsString	| result |	result := ''.	sourcetext peek = $'		ifFalse: [^ nil].	sourcetext next.	[sourcetext atEnd		ifTrue: [self error: 'string can`t end here'.			^ '''', result , '''' -> #string].	sourcetext peek = $'		ifTrue: [sourcetext next.			sourcetext peek ~= $'				ifTrue: [^ '''' , result , '''' -> #string]].	true]		whileTrue: [result := result , sourcetext next asString].	^ nil! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 2/7/2008 21:09'!contents	| result |	result := OrderedCollection new.	sourcetext reset.	self do: [:token | result add: token].	^result.! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 2/9/2008 15:30'!last	^lasttoken.! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 2/9/2008 15:30'!next	| result |	errormode		ifTrue: [^ ''].	self trimSpaces.	sourcetext atEnd		ifTrue: [^ nil].	"primitive"	(result := self nextTokenAsPrimitive)		ifNotNil: [^(lasttoken _ result)].	"number"	(result := self nextTokenAsNumber)		ifNotNil: [^(lasttoken _ result)].	"block arg"	(result := self nextTokenAsBlockArg)		ifNotNil: [^(lasttoken _ result)].	"literal or array"	(result := self nextTokenAsLiteralOrArray)		ifNotNil: [^(lasttoken _ result)].	"char"	(result := self nextTokenAsChar)		ifNotNil: [^(lasttoken _ result)].	"string"	(result := self nextTokenAsString)		ifNotNil: [^(lasttoken _ result)].	"comment"	(result := self nextTokenAsComment)		ifNotNil: [^(lasttoken _ result)].	"assign"	(result := self nextTokenAsAssign)		ifNotNil: [^(lasttoken _ result)].	"name or keymess"	(result := self nextTokenAsNameOrKeymess)		ifNotNil: [^(lasttoken _ result)].	"binnary mesage"	(result := self nextTokenAsBinMess)		ifNotNil: [^(lasttoken _ result)].	"simple tokens"	(result := self nextTokenAsSpecialToken)		ifNotNil: [^(lasttoken _ result)].	"else error recognision"	self error: 'not recognized!!'.	sourcetext next.	^ self next! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 2/9/2008 14:41'!originalContents	^sourcetext originalContents.! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 2/9/2008 15:26'!parsedText	^sourcetext originalContents first: sourcetext position.! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 1/28/2008 14:24'!position	^sourcetext position.! !!MySTLexicalAnalyzerStream methodsFor: 'error' stamp: 'SZ 1/2/2008 21:39'!error: aString 	"aString explore.	self halt"	errormode := true.!]style[(7 7 4 7 11 4 26)f2b,f2cblue;b,f2,f2cblue;i,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'testing' stamp: 'SZ 1/3/2008 11:16'!atEnd	self trimSpaces.	^ sourcetext atEnd!]style[(23 4 10 6)f2b,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private' stamp: 'SZ 2/7/2008 21:35'!trimSpaces	"trim spaces"	[sourcetext atEnd = false and: [sourcetext peek isSeparator]]		whileTrue: [sourcetext next].! !!MySTLexicalAnalyzerStream methodsFor: 'converting' stamp: 'SZ 1/3/2008 15:04'!asArray	^self contents asArray!]style[(7 3 4 17)f2b,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'converting' stamp: 'SZ 1/21/2008 19:48'!asOrderedCollection	| result |	result _ OrderedCollection new.	self contents do: [:token| result add: token key].	^result.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTLexicalAnalyzerStream class	instanceVariableNames: ''!!MySTLexicalAnalyzerStream class methodsFor: 'instance creation' stamp: 'SZ 1/2/2008 14:28'!on: aString 	^self basicNew initialize: aString!]style[(4 7 4 4 22 7)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !!MySTLexicalAnalyzerStream class methodsFor: 'converting' stamp: 'SZ 1/19/2008 15:08'!whatType: aString	^(self on: aString) next value.! !TestCase subclass: #MySTLexicalAnalyzerStreamTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:13'!testBinMessages	| test |	test := MySTLexicalAnalyzerStream on: '~= == ~~ <= >= <> || && + - 12 +- // '.	self should: test next = ('~=' -> #binmessage).	self should: test next = ('==' -> #binmessage).	self should: test next = ('~~' -> #binmessage).	self should: test next = ('<=' -> #binmessage).	self should: test next = ('>=' -> #binmessage).	self should: test next = ('<>' -> #binmessage).	self should: test next = ('||' -> #binmessage).	self should: test next = ('&&'->#binmessage).	self should: test next = ('+' -> #binmessage).	self should: test next = ('-' -> #binmessage).	self should: test next = ('12' -> #number).	self should: test next = ('+-'->#binmessage).	self should: test next = ('//' -> #binmessage).	self should: test atEnd.!]style[(15 3 5 4 4 4 25 5 39 3 4 9 4 9 20 3 4 9 4 9 20 3 4 9 4 9 20 3 4 9 4 9 20 3 4 9 4 10 19 3 4 9 4 9 20 3 4 9 4 9 20 3 4 9 4 9 18 3 4 9 4 9 19 3 4 9 4 9 19 3 4 9 4 9 16 3 4 9 4 9 18 3 4 9 4 9 20 3 4 9 4 7)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 12:08'!testBlockArgs	| test |	test := MySTLexicalAnalyzerStream on: '[:a :asdf123 :_tmp_|]'.	self should: test next = ('[' -> #token).	self should: test next = (':a'->#blockarg).	self should: test next = (':asdf123'->#blockarg).	self should: test next = (':_tmp_' -> #blockarg).	self should: test next = ('|' -> #binmessage).	self should: test next = (']' -> #token).	self should: test atEnd.! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/26/2008 18:36'!testChars0	"test := MySTSourceString with: '#(()))'.	self should: test size == 2.	self should: (test at: 1)	= '#(())'.	self should: (test at: 2)	= ')'."	| test |	test := MySTLexicalAnalyzerStream on: '$(123)'.	self should: test next = ('$('->#char).	self should: test next = ('123'->#number).	self should: test next = (')'->#token).! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/7/2008 22:05'!testChars1	| test |	test := MySTLexicalAnalyzerStream on: '	. , | :=)([]"123"''345''; #() < > ^$.#word123 <primZero>'.	self should: test next = ('.' -> #token).	self should: test next = (',' -> #binmessage).	self should: test next = ('|' -> #binmessage).	self should: test next = (':=' -> #assign).	self should: test next = (')' -> #token).	self should: test next = ('(' -> #token).	self should: test next = ('[' -> #token).	self should: test next = (']' -> #token).	self should: test next = ('"123"' -> #comment).	self should: test next = ('''345''' -> #string).	self should: test next = (';' -> #token).	self should: test next = ('#()' -> #array).	self should: test next = ('<' -> #binmessage).	self should: test next = ('>' -> #binmessage).	self should: test next = ('^' -> #token).	self should: test next = ('$.' -> #char).	self should: test next = ('#word123' -> #literal).	self should: test next = ('<primZero>' -> #primitive).	self should: test atEnd! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:06'!testChars2	| test |	test := MySTLexicalAnalyzerStream on: '~ ` @ % & ? * - = + \ / { }'.	self should: test next = ('~'->#binmessage).	self should: test next = ('`'->#binmessage).	self should: test next = ('@' -> #binmessage).	self should: test next = ('%' -> #binmessage).	self should: test next = ('&' -> #binmessage).	self should: test next = ('?'-> #binmessage).	self should: test next = ('*' -> #binmessage).	self should: test next = ('-'->#binmessage).	self should: test next= ('='->#binmessage).	self should: test next = ('+'->#binmessage).	self should: test next = ('\' -> #binmessage).	self should: test next = ('/'-> #binmessage).	self should: test next = ('{'->#binmessage).	self should: test next = ('}' -> #binmessage).	self should: test atEnd.!]style[(10 3 5 4 4 34 29 3 4 9 4 9 17 3 4 9 4 9 17 3 4 9 4 9 19 3 4 9 4 9 19 3 4 9 4 9 19 3 4 9 4 9 18 3 4 9 4 9 19 3 4 9 4 9 17 3 4 9 4 8 17 3 4 9 4 9 17 3 4 9 4 9 19 3 4 9 4 9 18 3 4 9 4 9 17 3 4 9 4 9 19 3 4 9 4 1 6)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 12:15'!testCode1	| test |	test := MySTLexicalAnalyzerStream on: 'clear: size ^(Interval newFrom: 0 to: size - 1 step: 1) do: [:item| <primitive: 112> value: item].'.	self should: test next = ('clear:' -> #keymessage).	self should: test next = ('size' -> #name).	self should: test next = ('^' -> #token).	self should: test next = ('(' -> #token).	self should: test next = ('Interval' -> #name).	self should: test next = ('newFrom:' -> #keymessage).	self should: test next = ('0' -> #number).	self should: test next = ('to:' -> #keymessage).	self should: test next = ('size' -> #name).	self should: test next = ('-' -> #binmessage).	self should: test next = ('1' -> #number).	self should: test next = ('step:' -> #keymessage).	self should: test next = ('1' -> #number).	self should: test next = (')' -> #token).	self should: test next = ('do:' -> #keymessage).	self should: test next = ('[' -> #token).	self should: test next = (':item' -> #blockarg).	self should: test next = ('|' -> #binmessage).	self should: test next = ('<primitive: 112>' -> #primitive).	self should: test next = ('value:' -> #keymessage).	self should: test next = ('item' -> #name).	self should: test next = (']'->#token).	self should: test next = ('.' -> #token).	self should: test atEnd.! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 10:42'!testCreation	self		should: ((MySTLexicalAnalyzerStream on: 'Object')				isMemberOf: MySTLexicalAnalyzerStream).!]style[(12 2 4 11 1 31 8 45)f2b,f2,f2cmagenta;,f2,f2b,f2,f2c255148000,f2! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:14'!testKeymessage	| test |	test := MySTLexicalAnalyzerStream on: 'at:put: new: Asffggh1234:'.	self should: test next = ('at:' -> #keymessage).	self should: test next = ('put:' -> #keymessage).	self should: test next = ('new:' -> #keymessage).	self should: test next = ('Asffggh1234:' -> #keymessage).	self should: test atEnd.!]style[(14 3 5 4 4 4 25 5 27 3 4 9 4 9 5 4 11 4 4 9 4 9 6 4 11 4 4 9 4 9 6 4 11 4 4 9 4 9 14 4 11 28)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 10:37'!testNumbers	| test |	test := MySTLexicalAnalyzerStream on: ' 	123 0  -123	0.01		1212435436346.009234 		0.987		123 -0.09'.	self should: test next = ('123' -> #number).	self should: test next = ('0' -> #number).	self should: test next = ('-123'-> #number).	self should: test next = ('0.01' -> #float).	self should: test next = ('1212435436346.009234'->#float).	self should: test next = ('0.987' -> #float).	self should: test next = ('123' -> #number).	self should: test next = ('-0.09' -> #float).	self should: test atEnd.!]style[(11 3 5 4 4 4 25 5 65 3 4 9 4 9 17 3 4 9 4 9 15 3 4 9 4 9 17 3 4 22 17 3 4 9 4 9 31 3 4 22 18 3 4 9 4 9 17 3 4 9 4 9 18 3 4 9 4 1 6)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:20'!testSimpleAccess	| test |	test := MySTLexicalAnalyzerStream on: '123'.	self should: test next = ('123' -> #number).	self should: test atEnd.!]style[(16 3 5 4 4 4 25 5 5 3 4 9 4 9 17 27)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 10:33'!testWords	| test |	test := MySTLexicalAnalyzerStream on: ' 	Word word  word	word		word				word Word123 '.	self should: test next = ('Word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('Word123' -> #name).	self should: test atEnd.!]style[(9 3 5 4 4 4 25 5 51 3 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 9 4 5 28)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2! !Object subclass: #MySTSourceText	instanceVariableNames: 'sourcetext'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTSourceText methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 17:36'!asSourceString	^(MySTLexicalAnalyzerStream on: sourcetext) asOrderedCollection.! !!MySTSourceText methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 17:24'!initializeWith: aString	sourcetext _ aString.	^self.! !!MySTSourceText methodsFor: 'as yet unclassified' stamp: 'SZ 1/27/2008 20:07'!size	^sourcetext size.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceText class	instanceVariableNames: ''!!MySTSourceText class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 18:56'!newFrom: aString	| result |	(result := MySTSourceTextClass newFrom: aString)		ifNotNil: [^result].	(result := MySTSourceTextClassMethods newFrom: aString)		ifNotNil: [^result].	(result := MySTSourceTextMethods newFrom: aString)		ifNotNil: [^result].	^ MySTSourceTextCode newFrom: aString.! !MySTSourceText subclass: #MySTSourceTextClass	instanceVariableNames: 'classsuper classname classinstvars classvars classpooldict size'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTSourceTextClass methodsFor: 'as yet unclassified' stamp: 'SZ 2/7/2008 21:24'!initializeWith: aString	| analizestream |	analizestream _ MySTLexicalAnalyzerStream on: aString.	classsuper _ analizestream next key.	analizestream next = ('subclass:'->#keymessage) ifFalse: [^nil].	classname _ analizestream next key copyWithoutFirst.	analizestream next = ('instanceVariableNames:'->#keymessage) ifFalse: [^nil].	classinstvars _ analizestream next key.	analizestream next = ('classVariableNames:'->#keymessage) ifFalse: [^nil].	classvars _ analizestream next key.	analizestream next = ('poolDictionaries:'->#keymessage) ifFalse: [^nil].	classpooldict _ analizestream next key.	analizestream next = ('!!'->#token) ifTrue: [size _ analizestream position+1].	^self.! !!MySTSourceTextClass methodsFor: 'accessing' stamp: 'SZ 1/26/2008 18:44'!className	^classname.! !!MySTSourceTextClass methodsFor: 'accessing' stamp: 'SZ 1/26/2008 18:44'!classSuper	^classsuper.! !!MySTSourceTextClass methodsFor: 'accessing' stamp: 'SZ 2/9/2008 11:19'!classSuperName	^classsuper.! !!MySTSourceTextClass methodsFor: 'accessing' stamp: 'SZ 2/9/2008 11:54'!classVariableNames	classvars = '''''' 		ifTrue: [^#()]		ifFalse: [^((classvars copyFrom: 2 to: classvars size -1) findTokens: $ ) asArray].! !!MySTSourceTextClass methodsFor: 'accessing' stamp: 'SZ 2/9/2008 11:54'!instanceVariableNames	classinstvars = '''''' 		ifTrue: [^#()]		ifFalse: [^ ((classinstvars copyFrom: 2 to: classinstvars size - 1) findTokens: $ ) asArray].! !!MySTSourceTextClass methodsFor: 'accessing' stamp: 'SZ 1/27/2008 19:10'!poolDictionaries	^(classpooldict findTokens: $ ) asArray.! !!MySTSourceTextClass methodsFor: 'accessing' stamp: 'SZ 2/7/2008 21:24'!size	^size.! !!MySTSourceTextClass methodsFor: 'accessing' stamp: 'SZ 1/27/2008 19:03'!superClass	^classsuper.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextClass class	instanceVariableNames: ''!!MySTSourceTextClass class methodsFor: 'as yet unclassified' stamp: 'SZ 2/7/2008 21:17'!newFrom: aString	| analizestream |	"aString first = $!! ifFalse: [^nil]."	analizestream _ MySTLexicalAnalyzerStream on: aString.	analizestream next.	analizestream next = ('subclass:'->#keymessage) 		ifTrue: [^super new initializeWith: aString] 		ifFalse: [^nil].! !MySTSourceText subclass: #MySTSourceTextClassMethods	instanceVariableNames: 'forclass methods'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTSourceTextClassMethods methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 16:01'!collectMethodsFrom: aString 	(aString withoutLeadingBlanks first: 1) = '!!'		ifTrue: [^self].		methods add: (MySTSourceTextMethod newFrom: aString).	(methods last isKindOf: MySTSourceTextMethod) 		ifFalse: [^nil]		ifTrue: [			methods last forClass: self forClass.			^self collectMethodsFrom: (aString allButFirst: methods last size)].! !!MySTSourceTextClassMethods methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 16:01'!forClass	^'MetaClass_',forclass.! !!MySTSourceTextClassMethods methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 15:25'!initializeWith: aString forClass: aString2	forclass _ aString2.	methods _ OrderedCollection new.	self collectMethodsFrom: aString.		^self.! !!MySTSourceTextClassMethods methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 15:44'!initializeWith: aString header: aString2	| size |	forclass _ aString2 copyWithoutFirst first: (aString2 findString: ' ' startingAt: 1) - 2.	methods _ OrderedCollection new.	(self collectMethodsFrom: aString) ifNil: [^nil].		size _ 0.	methods do: [:method | size _ size + method size].	size _ size + ((aString allButFirst: size) findString: '!!' startingAt: 1).	super initializeWith: aString2 , (aString first: size).	^self.! !!MySTSourceTextClassMethods methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 15:11'!methods	^methods.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextClassMethods class	instanceVariableNames: ''!!MySTSourceTextClassMethods class methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 15:36'!newFrom: aString	| stream |	stream _ MySTLexicalAnalyzerStream on: aString.	stream next = ('!!'->#token) 		ifFalse: [^nil].	stream next value = #name 		ifFalse: [^nil].	(stream next = ('class'->#name)) & (stream next = ('methods'->#name)) 		ifFalse: [^nil].	stream next = ('!!'->#token) 		ifFalse: [^nil].	^super new 		initializeWith: (aString allButFirst: stream position) 		header: (aString first: stream position).! !MySTSourceText subclass: #MySTSourceTextCode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTSourceTextCode methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 20:01'!asCompiled	| expressions |	expressions _ OrderedCollection new.! !!MySTSourceTextCode methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:04'!compile	^nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextCode class	instanceVariableNames: ''!!MySTSourceTextCode class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:01'!newFrom: aString	^super new initializeWith: aString.! !MySTSourceText subclass: #MySTSourceTextMethod	instanceVariableNames: 'message args body forClass expressions'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 15:45'!collectExpressions: aSourceString	| newString result |	newString _ aSourceString.		[newString first = '.' | ((MySTLexicalAnalyzerStream whatType: newString first) = #comment)]		whileTrue: [			newString _ newString copyWithoutFirst.			newString ifEmpty: [^OrderedCollection new.]].			result _ (MySTExpression newFrom: newString) first: 1.	(result first isKindOf: MySTExpression) 		ifFalse: [self halt].	newString _ newString allButFirst: result first size.	newString isEmpty		ifTrue: [^result.]		ifFalse: [^result , (self collectExpressions: newString)].! !!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 15:17'!forClass	^forClass.! !!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 15:17'!forClass: anObject	forClass _ anObject.! !!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 15:05'!initializeWith: aString	| sourceStringStream|	sourceStringStream _ MySTLexicalAnalyzerStream on: aString.		(self processMessageAndArgsFrom: sourceStringStream) ifNil: [^nil].		self processBodyFrom: sourceStringStream.	expressions _ self collectExpressions: (MySTLexicalAnalyzerStream on: body) asOrderedCollection.	^self.! !!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 16:09'!processBody	| sourcestream |	sourcestream _ MySTLexicalAnalyzerStream on: sourcetext.	args 		ifNotNil: [sourcestream next: args size * 2]		ifNil: [sourcestream next].		body _ sourcetext allButFirst: sourcestream position.	body _ body withoutLeadingBlanks withoutTrailingBlanks.	body last = $!! 		ifTrue: [body _  body first: body size - 1].			! !!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 15:34'!processBodyFrom: aStream	| sourceString token |	sourceString _ OrderedCollection new.	token _ aStream last.		[token = ('!!'->#token) | aStream atEnd] 		whileFalse: [sourceString add: token.			token _ aStream next].			body _ aStream parsedText allButFirst: sourcetext size.	sourcetext _ aStream parsedText.	body _ body withoutLeadingBlanks withoutTrailingBlanks.	body last = $!! 		ifTrue: [body _  body first: body size - 1].		! !!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 17:35'!processMessageAndArgs	| expr |	expr _ (MySTExpression newFrom: (self asSourceString copyWithFirst: 'anObject')) first.	(expr isKindOf: MySTExpressionKeyCall) |	(expr isKindOf: MySTExpressionBinCall) |	(expr isKindOf: MySTExpressionUnoCall) 		ifFalse: [^nil].	message _ expr callMessage.	args _ expr callArgs.			! !!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 15:33'!processMessageAndArgsFrom: aStream	| token |	message _ ''.	args _ OrderedCollection new.	token _ aStream next.			token value = #name 		ifTrue: [message _ token key. 			sourcetext _ aStream parsedText.			^aStream next.].			token value = #binmessage 		ifTrue: [message _ token key.			args add: (MySTExpressionObject withName: aStream next key).			sourcetext _ aStream parsedText.			^aStream next.].			token value = #keymessage 		ifTrue: [			[token value = #keymessage] 				whileTrue: [					message _ message, token key.						args add: (MySTExpressionObject withName: aStream next key).					sourcetext _ aStream parsedText.					token _ aStream next].			^token.		].			^nil.	! !!MySTSourceTextMethod methodsFor: 'accessing' stamp: 'SZ 1/28/2008 17:48'!arguments	args 		ifNil: [^OrderedCollection new.]		ifNotNil: [^args].	! !!MySTSourceTextMethod methodsFor: 'accessing' stamp: 'SZ 1/28/2008 14:41'!body	^body.! !!MySTSourceTextMethod methodsFor: 'accessing' stamp: 'SZ 2/2/2008 11:51'!expressions	^expressions ! !!MySTSourceTextMethod methodsFor: 'accessing' stamp: 'SZ 1/26/2008 18:09'!message	^message value.! !!MySTSourceTextMethod methodsFor: 'accessing' stamp: 'SZ 1/28/2008 14:53'!size	^sourcetext size.! !!MySTSourceTextMethod methodsFor: 'converting' stamp: 'SZ 1/28/2008 17:30'!asCompiledMethod	^MySTCompiledMethod newFrom: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextMethod class	instanceVariableNames: ''!!MySTSourceTextMethod class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:45'!newFrom: aString	^super new initializeWith: aString.! !MySTSourceTextClassMethods subclass: #MySTSourceTextMethods	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTSourceTextMethods methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 16:01'!forClass	^forclass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextMethods class	instanceVariableNames: ''!!MySTSourceTextMethods class methodsFor: 'as yet unclassified' stamp: 'SZ 2/7/2008 21:41'!newFrom: aString	| stream |	stream _ MySTLexicalAnalyzerStream on: aString.	stream next = ('!!'->#token) 		ifFalse: [^nil].	stream next value = #name 		ifFalse: [^nil].	stream next = ('methods'->#name)		ifFalse: [^nil].	stream next = ('!!'->#token) 		ifFalse: [^nil].	^super new 		initializeWith: (aString allButFirst: stream position) 		header: (aString first: stream position).! !TestCase subclass: #MySTSourceTextTestCase	instanceVariableNames: 'text'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-SourceText'!!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 17:47'!testGetArgsCount	self should: (MySTSourceTextMethod newFrom: 'isObject ^true.!!') arguments size = 0.	self should: (MySTSourceTextMethod newFrom: '== aObject ^<primitive: 21> value: self value: aObject.!!') arguments size = 1.	self should: (MySTSourceTextMethod newFrom: 'at: aNumber put: aObject ^<primitive: 23> value: self value: aNumber value: aObject.!!') arguments size = 2.! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 12/25/2007 20:50'!testGetBytecode	self		should: [(MySTSourceText with: 'isObject ^true.!!') getBytecode = #(164 0 1 208 )].	self		should: [(MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getBytecode = #(112 0 117 1 0 32 21 208 )].	self		should: [(MySTSourceText with: '<= aMagnitude ^(self > aMagnitude) not.!!') getBytecode = #(117 0 0 132 0 148 1 208 )]!]style[(15 2 4 13 14 7 18 16 15 4 4 13 14 7 58 16 27 4 4 13 14 7 42 16 27 1)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/8/2008 13:29'!testGetClass	| test |	test _ MySTSourceText newFrom: 'Object subclass: #Object2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: ''''!!'.	self should: (test isKindOf: MySTSourceTextClass).	self should: test className = 'Object2'.	self should: test classSuper = 'Object'.! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 15:41'!testGetClassMethods	| meths test |	test := MySTSourceText newFrom: '!!Object class methods !! new	^<primitive: 11> value: 0.!! new: aSize ^<primitive: 11> value: aSize.!!   !!   '.	self should: (test isKindOf: MySTSourceTextClassMethods).	meths _ test methods.	self should: (meths isSequenceable) & (meths size = 2).	self should: ((meths at: 1) isKindOf: MySTSourceTextMethod).	self should: ((meths at: 2) isKindOf: MySTSourceTextMethod).	self should: (meths at: 1) forClass asString = 'MetaClass_Object'.	self should: (meths at: 2) forClass asString = 'MetaClass_Object'.! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 11:51'!testGetClassVarNames	self should: (MySTSourceText newFrom: 'Object subclass: #Object2 instanceVariableNames: ''var1 var2 anyvar OurVar'' classVariableNames: ''ivar1 ivar2 IVar3'' poolDictionaries: ''''!!') classVariableNames = #('ivar1' 'ivar2' 'IVar3' )! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 11:51'!testGetInstVarNames	| test |	test _ MySTSourceText newFrom: 'Object subclass: #Object2 instanceVariableNames: ''var1 var2 anyvar OurVar'' classVariableNames: '''' poolDictionaries: ''''!!'.	self	should: test instanceVariableNames = #('var1' 'var2' 'anyvar' 'OurVar' ).	self should: test classVariableNames = #().! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 10/20/2007 11:35'!testGetLitSegment	| testLitSeg |	testLitSeg := (MySTSourceText with: 'isObject ^true.!!') getLitSegment.	self		should: [testLitSeg size == 2].	self		should: [(testLitSeg at: 1)				== 'true'].	self		should: [(testLitSeg at: 2)				== 'value'].	testLitSeg := (MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getLitSegment.	self		should: [(testLitSeg at: 1)				== 'value:value:'].	testLitSeg := (MySTSourceText with: '<= aMagnitude ^(self > aMagnitude) not.!!') getLiterals.	self		should: [(testLitSeg at: 1) =='>'].	self should: [(testLitSeg at: 2) == 'not'].!]style[(17 3 11 4 10 5 14 7 18 18 4 12 10 9 1 4 4 13 10 5 1 9 6 4 4 13 10 5 1 9 7 4 10 5 14 7 58 18 4 13 10 5 1 9 14 19 14 7 42 16 4 33 3 47)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2c255147000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/30/2008 18:38'!testGetLiterals	self should: (MySTSourceTextMethod newFrom: 'isObject ^true.!!') asCompiledMethod literals = #('true' 'value' ) asOrderedCollection.	self		should: [(MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getLiterals == #('value:value:') asOrderedCollection].	self		should: [(MySTSourceText with: '<= aMagnitude ^(self > aMagnitude) not.!!') getLiterals == #('>' 'not')]! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:49'!testGetMessageString	self		should: [(MySTSourceTextMethod newFrom: 'isObject ^true.!!') message = 'isObject'].	self		should: [(MySTSourceTextMethod newFrom: '== aObject ^<primitive: 21> value: self value: aObject.!!') message = '=='].	self		should: [(MySTSourceTextMethod newFrom: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') message = 'at:'].! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 15:34'!testGetMethodBody	self should: (MySTSourceTextMethod  newFrom: 'isObject ^true.!!') body = '^true.'.	self should: (MySTSourceTextMethod newFrom: '== aObject ^<primitive: 21> value: self value: aObject.!!') body = '^<primitive: 21> value: self value: aObject.'.	self should: (MySTSourceTextMethod newFrom: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') body = '^<primitive: 22> value: self value: aNumber.'.! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 7/6/2007 20:09'!testGetMethodComments	self		should: [MySTSourceText with: 'at: aNumber put: aObject  "base method at:put:" ^<primitive: 23> value: self value: aNumber value: aObject.!!' getComments == (OrderedCollection with: 'base method at:put:')].!]style[(21 2 4 12 22 25 23 60 64 2)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:27'!testGetMethods	| srctext meths |	srctext := MySTSourceText with: '!!Object methods !! basicAt: aNumber ^<primitive: 19> value: self value: aNumber. !! at: aNumber ^<primitive: 22> value: self value: aNumber.!! !!'.	meths := srctext getMethodDefinitions.	self		should: [(meths at: 1) isMethodDefinition].	self		should: [(meths at: 2) isMethodDefinition].	self		should: [(meths at: 1) forClassInstance asString = 'Object'].	self		should: [(meths at: 2) forClassInstance asString = 'Object']!]style[(14 3 14 4 7 4 14 7 143 3 5 4 7 24 4 13 5 5 1 24 4 13 5 5 1 24 4 13 5 5 1 30 8 4 4 13 5 5 1 30 8 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/27/2008 19:09'!testGetPoolDictionaries	self should: (MySTSourceText newFrom: '!!Object subclass: #Object2 instanceVariableNames: ''var1 var2 anyvar OurVar'' classVariableNames: ''ivar1 ivar2 IVar3'' poolDictionaries: ''pool1 pool2 Pool3''!!') poolDictionaries = #('pool1' 'pool2' 'Pool3' )! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 10/20/2007 11:36'!testGetStartTmpSegment	| testArgSeg |	testArgSeg := (MySTSourceText with: 'isObject ^true.!!') getStartTmpSegment.	self		should: [testArgSeg size == 0].	testArgSeg := (MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getStartTmpSegment.	self		should: [testArgSeg size == 1].	self		should: [(testArgSeg at: 1)				== 'aObject'].	testArgSeg := (MySTSourceText with: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') getStartTmpSegment.	self		should: [testArgSeg size == 1].	self		should: [(testArgSeg at: 1)				== 'aNumber'].	testArgSeg := (MySTSourceText with: 'at: aNumber put: aNumber2 ifError: aBlock (<primitive: 22> value: aNumber value: aNumber2) ifFalse: [aBlock value].!!') getStartTmpSegment.	self		should: [testArgSeg size == 3].	self		should: [(testArgSeg at: 1)				== 'aNumber'].	self		should: [(testArgSeg at: 2)				== 'aNumber2'].	self		should: [(testArgSeg at: 3)				== 'aBlock']!]style[(22 3 11 4 10 5 14 7 18 5 15 3 4 12 10 9 1 4 10 5 14 7 58 5 15 3 4 12 10 9 1 4 4 13 10 5 1 9 9 4 10 5 14 7 59 5 15 3 4 12 10 9 1 4 4 13 10 5 1 9 9 4 10 5 14 7 118 5 15 3 4 12 10 9 1 4 4 13 10 5 1 9 9 4 4 13 10 5 1 9 10 4 4 13 10 5 1 9 8 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/27/2008 19:02'!testGetSuperClass	self		should: (MySTSourceText newFrom: '!!Object subclass: #Object2 instanceVariableNames: ''var1 var2 anyvar OurVar'' classVariableNames: '''' poolDictionaries: ''''!!') superClass = 'Object'.! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 10/20/2007 11:37'!testGetTmpSegment	| testArgSeg |	testArgSeg := (MySTSourceText with: 'isObject ^true.!!') getArgSerment.	self		should: [testArgSeg size == 0].	testArgSeg := (MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getArgSegment.	self		should: [testArgSeg size > 0].	self		should: [(testArgSeg at: 1)				== 'aObject'].	testArgSeg := (MySTSourceText with: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') getArgSegment.	self		should: [testArgSeg size > 0].	self		should: [(testArgSeg at: 1)				== 'aNumber'].	testArgSeg := (MySTSourceText with: 'at: aNumber put: aNumber2 ifError: aBlock (<primitive: 22> value: aNumber value: aNumber2) ifFalse: [aBlock value].!!') getArgSegment.	self		should: [testArgSeg size > 2].	self		should: [(testArgSeg at: 1)				== 'aNumber'].	self		should: [(testArgSeg at: 2)				== 'aNumber2'].	self		should: [(testArgSeg at: 3)				== 'aBlock']!]style[(17 3 11 4 10 5 14 7 18 18 4 12 10 9 1 4 10 5 14 7 58 18 4 12 10 8 1 4 4 13 10 5 1 9 9 4 10 5 14 7 59 18 4 12 10 8 1 4 4 13 10 5 1 9 9 4 10 5 14 7 118 18 4 12 10 8 1 4 4 13 10 5 1 9 9 4 4 13 10 5 1 9 10 4 4 13 10 5 1 9 8 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:32'!testIsBinMessageMethod	self		should: [(MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') isBinMessageMethod]!]style[(22 2 4 13 14 7 1 56 1 21)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 15:42'!testIsClassMethods	|test|	test _ MySTSourceText newFrom: '!!Object class methods !! new	^<primitive: 11> value: 0.!! new: aSize ^<primitive: 11> value: aSize.!! !!'.	self should: (test isKindOf: MySTSourceTextClassMethods ).	self should: test size = 100.! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:33'!testIsKeyMessageMethod	self		should: [(MySTSourceText with: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') isKeyMessageMethod]!]style[(22 2 4 13 14 7 1 57 1 21)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/28/2008 14:56'!testIsMethod	| test |	test _ MySTSourceTextMethod newFrom: 'isObject ^true.!!'.	self should: (test isKindOf: MySTSourceTextMethod).	self should: (test size = 16).	test _ MySTSourceTextMethod newFrom: '== aObject ^<primitive: 21> value: self value: aObject.!!'.	self should: (test isKindOf: MySTSourceTextMethod).	self should: (test size = 56).	test _ MySTSourceTextMethod newFrom: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!'.	self should: (test isKindOf: MySTSourceTextMethod).	self should: (test size = 57).! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:17'!testIsMethods	self		should: [(MySTSourceText with: '!!Object methods !! basicAt: aNumber ^<primitive: 19> value: self value: aNumber. !! at: aNumber ^<primitive: 22> value: self value: aNumber.!! !!') isMethodsDefinition]!]style[(13 2 4 13 14 7 143 22)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:26'!testIsUnoMessageMethod	self should: [(MySTSourceText with: 'isObject ^true.!!') isUnoMessageMethod].!]style[(22 15 1 1 14 7 39 1)f2b,f2,f2b,f2,f2cmagenta;,f2,f2c255148000,f2! !