Object subclass: #MySTCompiledBlock	instanceVariableNames: 'image bytecode literals temps'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!Object subclass: #MySTCompiledClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!Object subclass: #MySTCompiledMethod	instanceVariableNames: 'image bytecode literals temps'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!TestCase subclass: #MySTCompilerTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 21:03'!testBlock1"bytecode in block ???"	| code |	code := MySTCompiler compile: '[:a | a]'.	self		should: [code bytecode = #(116 0 0 32 9 )].	self should: code literals size = 1.	self		should: [(code literals at: 1) isBlock].	self		should: [(code literals at: 1) bytecode == #(86 0 )].	self		should: [(code literals at: 1) argCount == 1].	self		should: [(code literals at: 1) tmpCount == 0]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 21:01'!testBlock2	| code |	code := MySTCompiler compile: '[:a|] value: 1'.	self		should: [code bytecode == #(116 0 0 32 9 116 0 1 148 1 )].	self should: code literals size = 3.	self		should: [(code literals at: 2)				== 1].	self should: (code literals at: 3) == 'value:'.	self		should: [(code literals at: 1) isBlock].	self		should: [(code literals at: 1) bytecode size == 0].	self		should: [(code literals at: 1) argCount == 1].	self		should: [(code literals at: 1) tmpCount == 0].	self		should: [(code literals at: 1) literals count == 0]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 21:02'!testBlock3	| code |	code := MySTCompiler compile: '[:a | a asInteger] value: 1'.	self		should: [code bytecode = #(116 0 0 32 9 116 0 1 148 1 )].	self		should: [code literals size == 3].	self		should: [(code literals at: 2)				== 1].	self should: [(code literals at: 3) == 'value:'].	self		should: [(code literals at: 1) isBlock].	self		should: [(code literals at: 1) bytecode == #(180 0 0 )].	self		should: [(code literals at: 1) literals size == 1 && (((code literals at: 1) literals at: 1)					== 'asInteger')].	self		should: [(code literals at: 1) argCount == 1].	self		should: [(code literals at: 1) tmpCount == 0]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 21:02'!testBlock4	| code |	code := MySTCompiler compile: '[:a :b| a+b] value: 1 value: 2'.	self		should: [code bytecode = #(116 0 0 32 9 116 0 1 116 1 2 148 3 )].	self		should: [code literals size == 4].	self		should: [(code literals at: 2)				== 1].	self		should: [(code literals at: 3)				== 2].	self should: [(code literals at: 4) == 'value:value:'].	self		should: [(code literals at: 1) isBlock].	self		should: [(code literals at: 1) bytecode == #(117 0 1 172 0 0 )].	self		should: [(code literals at: 1) literals size == 1].	self		should: [((code literals at: 1) literals at: 1)				== '+'].	self		should: [(code literals at: 1) argCount == 2].	self		should: [(code literals at: 1) tmpCount == 0]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:57'!testBlock5	| code block1 |	code := MySTCompiler compile: '[:a :abc :bcd :hjk| abc at: 1 put: 2. ^hjk] value: 1.'.	self		should: [code bytecode = #(116 0 0 32 9 116 0 1 148 2 )].	self		should: [code literals size == 3].	self		should: [(code literals at: 2)				== 1].	self should: [(code literals at: 1) == 'value:'].	block1 := code literals at: 1.	self		should: [block1 isBlock].	self		should: [block1 bytecode == #(116 0 1 116 1 2 172 1 0 232 3 )].	self		should: [block1 literals size == 3].	self		should: [(block1 literals at: 3)				== 'at:put:'].	self		should: [(block1 literals at: 1)				== '1'].	self		should: [(block1 literals at: 2)				== '2'].	self		should: [block1 argCount == 4].	self		should: [block1 tmpCount == 0]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 21:01'!testBlock6	"bytecode in testBlock1 ???"	| code |	code := MySTCompiler compile: '^[1] value'.	self		should: [code bytecode = #(116 0 0 32 9 148 1 208 )].	self		should: [code literals code == 2].	self		should: [(code literals at: 1) isBlock].	self		should: [(code literals at: 1) bytecode == #(84 0 )].	self		should: [(code literals at: 1) literals size == 1].	self		should: [((code literals at: 1) literals at: 1)				== '1'].	self		should: [(code literals at: 1) argCount == 0].	self		should: [(code literals at: 1) tmpCount == 0]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:59'!testBlock7	"direct method compiling DISABLED!!"	| code block1 |	code := MySTCompiler compile: '[:a| a=0 ifTrue: [3]].'."	self		should: code bytecode = #(???)."	self		should: code literals size = 1.	block1 := code literals at: 1.	self		should: block1 isBlock.	self		should: block1 bytecode = #(116 0 1 172 0 0 106 1 116 0 3 32 9 114 0 172 1 2).	self		should: block1 literals size = 4.	self		should: (block1 literals at: 1)				= '='.	self		should: (block1 literals at: 2)				= '0'.	self		should: (block1 literals at: 3)				= 'ifTrue:'.	self		should: (block1 literals at: 4) isBlock.! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:59'!testBlock8	| code block1 |	code := MySTCompiler compile: '[a at: 1+1 put: ''123'' size+1*4]'.	self should: code bytecode = #().	self should: code literals size == 1.	block1 := code literals at: 1.	self should: block1 isBlock.	self should: block1 bytecode == #(164 0 1 106 0 116 0 5 164 3 4 106 1 164 6 7 116 0 9 148 8 116 0 11 148 10 117 0 1 114 1 172 2 0 ).	self should: block1 literals size == 12.	self should: (block1 literals at: 1)			== 'a'.	self should: (block1 literals at: 1) isSymbol.	self should: (block1 literals at: 2)			== 'value'.	self should: (block1 literals at: 3)			== 'at:put:'.	self should: (block1 literals at: 4)			== '1'.	self should: (block1 literals at: 5)			== '+'.	self should: (block1 literals at: 6)			== '1'.	self should: (block1 literals at: 7)			== '123'.	self should: (block1 literals at: 8)			== 'size'.	self should: (block1 literals at: 9)			== '+'.	self should: (block1 literals at: 10)			== '1'.	self should: (block1 literals at: 11)			== '*'.	self should: (block1 literals at: 12)			== '4'.	self should: block1 temps size == 2.	self should: block1 arguments size == 0.! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 21:00'!testBlock9	"direct method compiling DISABLED!!"	| code block1 block2 block3 |	code := MySTCompiler compile: '[ self atEnd ] whileFalse: [		self next = anObject ifTrue: [ ^true ]].	^false' withMethodHeader: 'skipTo: anObject'.	self		should: [code isMethod].	self		should: [code message = 'skipTo:'].	self		should: [code bytecode = #(116 0 0 32 9 106 0 116 0 2 32 9 114 0 172 0 1 164 4 5 208 )].	self		should: [code literals size == 3].	block1 := code literals at: 1.	self		should: [block1 isBlock].	self		should: [block1 bytecode == #(132 0 )].	self		should: [block1 literals size == 1].	self		should: [(block1 literals at: 1)				== 'atEnd'].	block2 := code literals at: 2.	self should: block2 isBlock.	self should: block2 literals size = 4.	self should: (block2 literals at: 1)			== 'next'.	self should: (block2 literals at: 2)			== '='.	self should: (block2 literals at: 3)			= 'ifTrue:'.	self should: block2 bytecode == #(132 0 117 0 0 148 1 106 1 116 0 3 32 9 114 0 172 1 2 ).	block3 := block2 literals at: 4.	self should: block3 isBlock.	self should: block3 bytecode == #(164 0 1 208 ).	self should: block3 literals size == 2.	self		should: [(block3 literals at: 1)				== 'true'].	self		should: [(block3 literals at: 2)				== 'value']! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:32'!testCascadeCall	| test |	test _ MySTCompiler compile: '1 clone; + 1; asString'.	self should: (test bytecode = #(164 0 1 116 0 3 164 0 2 164 0 4) | (test bytecode = #(164 2 1 116 0 4 164 2 3 164 2 0))).		test _ MySTCompiler compile: '''123'' asByteArray at: 1 put: 63 ; at: 2 set:56;at:3 replace:78; printOn: Transcript.'.	self should: [test bytecode = #(164 0 1 116 0 3 116 1 4 106 0 172 0 2 116 0 6 116 1 7 172 0 5 116 0 9 116 1 10 172 0 8 164 12 13 114 0 172 0 11)].! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:58'!testCode1	| code block1 |	code := MySTCompiler compile: '^(Interval newFrom: 1 to: 3 step: 1) do: [:item| <primitive: 112> value: item].' withMethodHeader: 'new'.	self should: code arguments size = 0.	self should: code temps size = 1.	self should: code literals size = 8.	self should: (code literals at: 1) = 'Interval'.	self should: (code literals at: 1) isSymbol.	self should: (code literals at: 2) = 'value'.	self should: (code literals at: 3) = 'newFrom:to:step:'.	self should: (code literals at: 4) = '1'.	self should: (code literals at: 5) = '3'.	self should: (code literals at: 6) = '1'.	self should: (code literals at: 7) = 'do:'.	self should: (code literals at: 8) isBlock.	self should: code bytecode = #(164 0 1 116 0 3 116 1 4 116 2 5 148 2 106 0 116 0 7 32 9 114 0 172 0 6).	block1 := code literals at: 8.	self should: block1 arguments size = 1.	self should: block1 literals size = 1.	self should: (block1 literals at: 1) = 'value:'.	self should: block1 bytecode = #(117 0 1 32 112).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 21:01'!testCode2	"at: zamenit na poisk na prisutstvii (?)	tmps: 	0 - arg1	1 - arg2	2 - arg3	3 - temp	4 - flag	5 - method: temp1	6 - block1: temp1	7 - block1: temp2"	| test lits block1 block2 block3 |	test := MySTCompiler compile: ' 	| temp flag |	temp := Bag new.	temp add: arg1.	temp count = 1 ifTrue: [(temp count = 2) ifTrue: [temp add: arg3. ^temp] ifFalse: [temp add: arg2]. flag := true.]	^ nil' withMethodHeader: 'arg1: arg1 arg2: arg2 arg3: arg3'.	self should: test isMethod.	self should: test arguments size = 3.	self should: test arguments = #('arg1' 'arg2' 'arg3' ).	self should: test message = 'arg1:arg2:arg3:'.	self should: test temps size = 2.	self should: test temps = #('temp' 'flag' ).	lits := test literals.	self should: lits size = 9.	self should: (lits at: 1)			= 'Bag'.	self should: (lits at: 1) isSymbol.	self should: (lits at: 2)			= 'value'.	self should: (lits at: 3)			= 'new'.	self should: (lits at: 4)			= 'add:'.	self should: (lits at: 5)			= 'count'.	self should: (lits at: 6)			= '='.	self should: (lits at: 7)			= 1.	self should: (lits at: 8)			= 'ifTrue:'.	self should: (lits at: 9) isBlock.	self should: (lits at: 10)			= 'nil'.	self should: (lits at: 10) isSymbol.	self should: (lits at: 11)			= 'value'.	self should: test bytecode = #(164 0 1 148 2 106 3 117 0 0 172 3 3 172 3 4 116 0 6 148 5 106 5 116 0 8 32 9 114 0 172 5 7 164 9 10 208 ).	block1 := lits at: 9.	self should: block1 temps size = 0.	self should: block1 arguments size = 0.	self should: block1 literals size = 8.	self should: (block1 literals at: 1)			= 'count'.	self should: (block1 literals at: 2)			= '='.	self should: (block1 literals at: 3)			= '2'.	self should: (block1 literals at: 4)			= 'ifTrue:ifFalse:'.	self should: (block1 literals at: 5) isBlock.	self should: (block1 literals at: 6) isBlock.	self should: (block1 literals at: 7)			= 'true'.	self should: (block1 literals at: 7) isSymbol.	self should: (block1 literals at: 8)			= 'value'.	self should: block1 bytecode = #(172 3 0 116 0 2 148 1 106 6 116 0 4 32 9 106 7 116 0 5 32 9 117 0 7 114 1 172 6 3 164 6 7 106 4 ).	block2 := block1 literals at: 5.	self should: block2 literals size = 1.	self should: (block2 literals at: 1)			= 'add:'.	self should: block2 bytecode = #(117 0 2 172 3 0 232 3 ).	block3 := block1 literals at: 6.	self should: block3 literals size = 1.	self should: (block3 literals at: 1)			= 'add:'.	self should: block3 bytecode = #(117 0 2 172 3 0 )! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:58'!testCode5	| code |	code := MySTCompiler compile: '| t4 t5 t6 t7 t8 t9 t10 t11 |	t7 := t1.	t9 := t3.	[t7 > self size ifTrue: [^ t9 > t2 size].	(self at: t7)	= $#]		whileTrue: [t9 > t2 size ifTrue: [^ false].	t7 := t7 + 1. t9 := t9 + 1].	(self at: t7)	= $*		ifTrue: [t7 = self size ifTrue: [^ true]. t4 := true.	t5 := t7 + 1]		ifFalse: [t4 := false. t5 := t7].	t6 := self size.	(t10 := self indexOf: $* startingAt: t5) > 0		ifTrue: [t10 = 1 ifTrue: [self error: ''** not valid -- use * instead'']. t6 := t10 - 1].	(t10 := self indexOf: $# startingAt: t5) > 0		ifTrue: [t10 = 1 ifTrue: [self error: ''*# not valid -- use #* instead'']. t6 := t6 min: t10 - 1].	t8 := self copyFrom: t5 to: t6.	[t11 := t2 findString: t8 startingAt: t9 caseSensitive: false. t4 ifTrue: [t11 > 0] ifFalse: [t11 = t9]]		whileTrue: [(self startingAt: t6 + 1 match: t2 startingAt: t11 + t8 size) ifTrue: [^ true]. t4 ifFalse: [^ false]. t9 := t9 + 1].	^ false' withMethodHeader: 'startingAt: t1 match: t2 startingAt: t3'.	self should: code literals size = 28.	self should: code bytecode = #(109 6 0 109 8 2 116 0 0 32 9 106 11 116 0 2 32 9 114 0 172 11 1 117 0 6 132 3 116 0 5 148 4 106 11 116 0 7 32 9 106 12 116 0 8 32 9 117 0 12 114 1 172 11 6 132 9 106 5 116 0 11 117 1 4 132 10 106 10 116 0 13 172 9 12 106 11 116 0 15 32 9 114 0 172 11 14 116 0 17 117 1 14 132 16 106 9 116 0 19 172 9 18 106 11 116 0 21 32 9 114 0 172 11 20 117 0 4 117 1 5 132 22 106 7 116 0 23 32 9 106 11 116 0 25 114 0 172 11 24 164 26 27 208 )! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:18'!testPrim	self		should: (MySTCompiler compile: '<primitive: 1> value') bytecode = #(32 1)! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:38'!testPrim2	self		should: (MySTCompiler compile: '^<primitive: 5> value: 1 value: 0') bytecode = #(116 0 0 116 1 1 32 5 208).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 16:09'!testRetGlobalLiteral	self		should: [(MySTCompiler compile: '^Object') bytecode = #(164 0 1 208)]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 15:38'!testRetSMBinResult	self		should: [(MySTCompiler compile: '^1 + 1') bytecode = #(116 0 2 164 0 1 208)]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:29'!testRetSMKeyResult	| result |		result _ MySTCompiler compile: '^$. new: 1'.	self should: (result bytecode = #(116 0 2 164 0 1 208)) | (result bytecode = #(116 0 1 164 2 0 208)).		result _ MySTCompiler compile: '^''123'' at: 1 put: 63.'.	self should: (result bytecode = #(116 0 1 116 1 2 164 3 0 208) | (result bytecode = #(116 0 2 116 1 3 164 0 1 208))).		result _ MySTCompiler compile: '^''123'' printOn: Transcript.'.	self should: (result bytecode = #(164 2 3 114 0 164 0 1 208) | (result bytecode = #(164 1 2 114 0 164 3 0 208))).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:25'!testRetSMUnoResult1	| test |	test _ MySTCompiler compile: '^1 asString'.	self should: (test bytecode = #(164 0 1 208)) | (test bytecode = #(164 1 0 208)).! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:59'!testRetSelf	self		should: [(MySTCompiler compile: '^self') bytecode = #(192 )]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/22/2008 20:57'!testRetSuper	self		should: [(MySTCompiler compile: '^super') bytecode = #(200 )]! !!MySTCompilerTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:25'!testRetTmp	self		should: [(MySTCompiler compile: '| var1 | ^var1') bytecode = #(232 0 )]! !Object subclass: #MySTImage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!Stream subclass: #MySTLexicalAnalyzerStream	instanceVariableNames: 'sourcetext errormode'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTLexicalAnalyzerStream methodsFor: 'initialize-release' stamp: 'SZ 1/2/2008 21:39'!initialize: aString 	sourcetext := ReadStream on: aString.	errormode := false.!]style[(12 7 3 10 19 29)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:23'!nextTokenAsAssign	sourcetext next = $: & sourcetext atEnd not		ifTrue: [sourcetext peek = $=				ifTrue: [sourcetext next.					^ ':=' -> #assign]]		ifFalse: [sourcetext back].	^nil.!]style[(17 2 10 8 2 3 10 22 10 8 2 14 10 14 4 4 7 15 10 14)f2b,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:21'!nextTokenAsBinMess	| result |	result := ''.	[#($, $- $+ $\ $/ $* $~ $` $= $@ $% $& $? ${ $} $< $> $| ) includes: sourcetext peek]		whileTrue: [result := result , sourcetext next asString.			sourcetext atEnd				ifTrue: [^ result -> #binmessage]].	result = ''		ifTrue: [^ nil]		ifFalse: [^ result -> #binmessage]!]style[(18 3 7 4 6 4 2 4 57 42 6 4 6 64 6 4 11 5 6 3 2 14 3 16 6 4 11 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 22:02'!nextTokenAsBlockArg	| result |	result := ''.	sourcetext next = $: & sourcetext atEnd not		ifTrue: [sourcetext peek isDigit				ifTrue: [self error: 'no digit in first letter of block arg name!!'.					sourcetext next.					^ nil].			[sourcetext atEnd not				and: [sourcetext peek isAlphaNumeric | (sourcetext peek = $_)]]				whileTrue: [result := result , sourcetext next asString].			result = ''				ifFalse: [^ result -> #blockarg]].	sourcetext back.	^ nil!]style[(19 3 7 4 6 4 2 3 10 8 2 3 10 22 10 27 4 8 45 7 10 14 3 7 10 21 10 24 10 8 2 20 6 4 6 3 10 20 6 3 2 17 19 5 10 10 3)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/23/2008 15:40'!nextTokenAsChar	sourcetext peek = '$' last		ifTrue: [sourcetext next.			sourcetext atEnd				ifTrue: [sourcetext back.					^ nil]				ifFalse: [^ ('$', sourcetext next asString) -> #char]].	^nil.! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/3/2008 11:27'!nextTokenAsComment	| result |	result := ''.	sourcetext peek = $" ifFalse: [^ nil].	sourcetext next.	[sourcetext atEnd ifTrue: [self error: 'comment can`t end here'. ^ result -> #comment].	sourcetext peek = $" ifTrue: [sourcetext next. ^ result -> #comment].	true]		whileTrue: [result := result , sourcetext next asString].	^ nil!]style[(18 3 7 4 6 4 2 3 10 8 3 12 3 4 10 9 10 16 4 8 24 4 6 4 8 4 10 8 3 28 6 4 8 4 4 16 6 4 6 3 10 20 3)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/26/2008 18:38'!nextTokenAsLiteralOrArray	| result |	result := ''.	sourcetext peek = $#		ifFalse: [^ nil].	sourcetext next.	sourcetext atEnd		ifTrue: [self error: 'literal can`t ending here!!'.			^ nil].	"take literal"	sourcetext peek isLetter		ifTrue: [[result := result , sourcetext next asString.			sourcetext peek isLetter | sourcetext peek isDigit] whileTrue.			^ '#',result -> #literal].	"take array"	sourcetext peek = $(		ifFalse: [self error: 'array no valid!!'.			^ nil].	[sourcetext atEnd		ifTrue: [self error: 'array no valid!!'.			^ nil].	result := result , sourcetext peek asString.	sourcetext next = $)] whileFalse.	sourcetext next.	^ '#',result -> #array! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/3/2008 11:19'!nextTokenAsNameOrKeymess	| result |	result := ''.	sourcetext peek isLetter | (sourcetext peek = $_)		ifTrue: [[sourcetext atEnd not				and: [sourcetext peek isAlphaNumeric | (sourcetext peek = $_)]]				whileTrue: [result := result , sourcetext next asString].			sourcetext peek = $:				ifTrue: [result := result , sourcetext next asString.					^ result -> #keymessage].			result ~= ''				ifTrue: [^ result -> #name]].	^ nil!]style[(24 3 7 4 6 4 2 3 10 18 10 8 2 14 10 21 10 24 10 8 2 20 6 4 6 3 10 20 10 8 2 14 6 4 6 3 10 23 6 4 11 6 6 4 2 16 6 4 5 7 3)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/3/2008 11:24'!nextTokenAsNumber	| result |	result := ''.	"take sign"	(sourcetext next = $- & sourcetext atEnd not			and: [sourcetext peek isDigit])		ifTrue: [result := '-']		ifFalse: [sourcetext back.			sourcetext peek isDigit				ifFalse: [^ nil]].	"take number"	[result := result , sourcetext next asString.	sourcetext atEnd		ifTrue: [^ result -> #number].	sourcetext peek isLetter		ifTrue: [self error: 'Letter in the end of number?'.			^ result -> #number].	sourcetext peek isDigit] whileTrue.	"take float part"	(sourcetext next = $. & sourcetext atEnd not			and: [sourcetext peek isDigit])		ifTrue: [result := result , '.'.			[result := result , sourcetext next asString.			sourcetext atEnd				ifTrue: [^ result -> #float].			sourcetext peek isLetter				ifTrue: [self error: 'Letter in the end of number?'.					^ result -> #float].			sourcetext peek isDigit] whileTrue.			^ result -> #float]		ifFalse: [sourcetext back].	^ result -> #number!]style[(17 3 7 4 6 4 2 3 11 3 10 8 2 3 10 20 10 27 6 4 3 14 10 10 10 30 3 5 13 3 6 4 6 3 10 17 10 20 6 4 7 4 10 26 4 8 30 7 6 4 7 4 10 27 17 3 10 8 2 3 10 20 10 27 6 4 6 3 3 6 6 4 6 3 10 19 10 22 6 4 6 6 10 28 4 8 30 9 6 4 6 6 10 31 6 4 6 14 10 11 6 4 7)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2c147045000,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c147045000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2c147045000,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/21/2008 20:59'!nextTokenAsPrimitive	| result |	result := ''.	sourcetext next = $< & sourcetext peek = $p		ifFalse: [sourcetext back.			^ nil].	[sourcetext atEnd		ifTrue: [self error: 'primitive can`t end here'.			^ nil].	sourcetext peek = $>]		whileFalse: [result := result , sourcetext next asString].	sourcetext next.	^ '<',result,'>' -> #primitive! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:26'!nextTokenAsSpecialToken	(#($!! $^ $; $. $[ $] $( $) $: $_ ) includes: sourcetext peek)		ifTrue: [^ sourcetext next asString -> #token]		ifFalse: [^nil].!]style[(23 3 33 11 10 20 10 18 6 20)f2b,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:28'!nextTokenAsString	| result |	result := ''.	sourcetext peek = $'		ifFalse: [^ nil].	sourcetext next.	[sourcetext atEnd		ifTrue: [self error: 'string can`t end here'.			^ result -> #string].	sourcetext peek = $'		ifTrue: [sourcetext next.			sourcetext peek ~= $'				ifTrue: [^ result -> #string]].	true]		whileTrue: [result := result , sourcetext next asString].	^ nil!]style[(17 3 7 4 6 4 2 3 10 8 2 15 3 4 10 9 10 18 4 8 23 7 6 4 7 4 10 8 2 12 10 10 10 9 2 16 6 4 7 5 4 16 6 4 6 3 10 20 3)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 1/3/2008 14:18'!contents	| result |	result := OrderedCollection new.	self		do: [:token | result add: token].	^result.!]style[(8 3 7 4 6 4 17 7 4 8 7 2 6 6 5 12)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cred;,f2,f2cblue;i,f2,f2cblue;i,f2! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 1/3/2008 11:27'!next	| result |	errormode		ifTrue: [^ ''].	self trimSpaces.	sourcetext atEnd		ifTrue: [^ nil].	"primitive"	(result := self nextTokenAsPrimitive)		ifNotNil: [^ result].	"number"	(result := self nextTokenAsNumber)		ifNotNil: [^ result].	"block arg"	(result := self nextTokenAsBlockArg)		ifNotNil: [^ result].	"literal or array"	(result := self nextTokenAsLiteralOrArray)		ifNotNil: [^ result].	"char"	(result := self nextTokenAsChar)		ifNotNil: [^ result].	"string"	(result := self nextTokenAsString)		ifNotNil: [^ result].	"comment"	(result := self nextTokenAsComment)		ifNotNil: [^ result].	"assign"	(result := self nextTokenAsAssign)		ifNotNil: [^ result].	"name or keymess"	(result := self nextTokenAsNameOrKeymess)		ifNotNil: [^ result].	"binnary mesage"	(result := self nextTokenAsBinMess)		ifNotNil: [^ result].	"simple tokens"	(result := self nextTokenAsSpecialToken)		ifNotNil: [^ result].	"else error recognision"	self error: 'not recognized!!'.	sourcetext next.	^ self next!]style[(4 3 7 4 9 14 2 4 4 14 10 20 3 4 11 3 6 4 4 38 6 4 8 3 6 4 4 35 6 4 11 3 6 4 4 37 6 4 18 3 6 4 4 43 6 4 6 3 6 4 4 33 6 4 8 3 6 4 4 35 6 16 6 4 4 36 6 4 8 3 6 4 4 35 6 4 17 3 6 4 4 42 6 4 16 3 6 4 4 36 6 4 15 3 6 4 4 41 6 4 24 2 4 8 17 3 10 10 4 5)f2b,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'error' stamp: 'SZ 1/2/2008 21:39'!error: aString 	"aString explore.	self halt"	errormode := true.!]style[(7 7 4 7 11 4 26)f2b,f2cblue;b,f2,f2cblue;i,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'testing' stamp: 'SZ 1/3/2008 11:16'!atEnd	self trimSpaces.	^ sourcetext atEnd!]style[(23 4 10 6)f2b,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private' stamp: 'SZ 1/2/2008 21:18'!trimSpaces	"trim spaces"	[sourcetext peek = Character space | (sourcetext peek = Character cr) | (sourcetext peek = Character tab)]		whileTrue: [sourcetext next].!]style[(10 2 13 3 10 8 9 10 10 8 9 8 10 8 9 21 10 7)f2b,f2,f2c148046000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'converting' stamp: 'SZ 1/3/2008 15:04'!asArray	^self contents asArray!]style[(7 3 4 17)f2b,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'converting' stamp: 'SZ 1/21/2008 19:48'!asOrderedCollection	| result |	result _ OrderedCollection new.	self contents do: [:token| result add: token key].	^result.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTLexicalAnalyzerStream class	instanceVariableNames: ''!!MySTLexicalAnalyzerStream class methodsFor: 'instance creation' stamp: 'SZ 1/2/2008 14:28'!on: aString 	^self basicNew initialize: aString!]style[(4 7 4 4 22 7)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !!MySTLexicalAnalyzerStream class methodsFor: 'converting' stamp: 'SZ 1/19/2008 15:08'!whatType: aString	^(self on: aString) next value.! !TestCase subclass: #MySTLexicalAnalyzerStreamTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:13'!testBinMessages	| test |	test := MySTLexicalAnalyzerStream on: '~= == ~~ <= >= <> || && + - 12 +- // '.	self should: test next = ('~=' -> #binmessage).	self should: test next = ('==' -> #binmessage).	self should: test next = ('~~' -> #binmessage).	self should: test next = ('<=' -> #binmessage).	self should: test next = ('>=' -> #binmessage).	self should: test next = ('<>' -> #binmessage).	self should: test next = ('||' -> #binmessage).	self should: test next = ('&&'->#binmessage).	self should: test next = ('+' -> #binmessage).	self should: test next = ('-' -> #binmessage).	self should: test next = ('12' -> #number).	self should: test next = ('+-'->#binmessage).	self should: test next = ('//' -> #binmessage).	self should: test atEnd.!]style[(15 3 5 4 4 4 25 5 39 3 4 9 4 9 20 3 4 9 4 9 20 3 4 9 4 9 20 3 4 9 4 9 20 3 4 9 4 10 19 3 4 9 4 9 20 3 4 9 4 9 20 3 4 9 4 9 18 3 4 9 4 9 19 3 4 9 4 9 19 3 4 9 4 9 16 3 4 9 4 9 18 3 4 9 4 9 20 3 4 9 4 7)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:08'!testBlockArgs	| test |	test := MySTLexicalAnalyzerStream on: '[:a :asdf123 :_tmp_|]'.	self should: test next = ('[' -> #token).	self should: test next = ('a'->#blockarg).	self should: test next = ('asdf123'->#blockarg).	self should: test next = ('_tmp_' -> #blockarg).	self should: test next = ('|' -> #binmessage).	self should: test next = (']' -> #token).	self should: test atEnd.!]style[(13 3 5 4 4 4 25 5 23 3 4 9 4 9 14 3 4 9 4 9 15 3 4 9 4 9 21 3 4 9 4 9 21 3 4 9 4 9 19 3 4 9 4 9 14 3 4 9 4 1 6)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/26/2008 18:36'!testChars0	"test := MySTSourceString with: '#(()))'.	self should: test size == 2.	self should: (test at: 1)	= '#(())'.	self should: (test at: 2)	= ')'."	| test |	test := MySTLexicalAnalyzerStream on: '$(123)'.	self should: test next = ('$('->#char).	self should: test next = ('123'->#number).	self should: test next = (')'->#token).! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/26/2008 18:39'!testChars1	| test |	test := MySTLexicalAnalyzerStream on: '	. , | :=)([]"123"''345''; #() < > ^$.#word123 <primZero>'.	self should: test next = ('.' -> #token).	self should: test next = (',' -> #binmessage).	self should: test next = ('|' -> #binmessage).	self should: test next = (':=' -> #assign).	self should: test next = (')' -> #token).	self should: test next = ('(' -> #token).	self should: test next = ('[' -> #token).	self should: test next = (']' -> #token).	self should: test next = ('123' -> #comment).	self should: test next = ('345' -> #string).	self should: test next = (';' -> #token).	self should: test next = ('#()' -> #array).	self should: test next = ('<' -> #binmessage).	self should: test next = ('>' -> #binmessage).	self should: test next = ('^' -> #token).	self should: test next = ('$.' -> #char).	self should: test next = ('#word123' -> #literal).	self should: test next = ('<primZero>' -> #primitive).	self should: test atEnd! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:06'!testChars2	| test |	test := MySTLexicalAnalyzerStream on: '~ ` @ % & ? * - = + \ / { }'.	self should: test next = ('~'->#binmessage).	self should: test next = ('`'->#binmessage).	self should: test next = ('@' -> #binmessage).	self should: test next = ('%' -> #binmessage).	self should: test next = ('&' -> #binmessage).	self should: test next = ('?'-> #binmessage).	self should: test next = ('*' -> #binmessage).	self should: test next = ('-'->#binmessage).	self should: test next= ('='->#binmessage).	self should: test next = ('+'->#binmessage).	self should: test next = ('\' -> #binmessage).	self should: test next = ('/'-> #binmessage).	self should: test next = ('{'->#binmessage).	self should: test next = ('}' -> #binmessage).	self should: test atEnd.!]style[(10 3 5 4 4 34 29 3 4 9 4 9 17 3 4 9 4 9 17 3 4 9 4 9 19 3 4 9 4 9 19 3 4 9 4 9 19 3 4 9 4 9 18 3 4 9 4 9 19 3 4 9 4 9 17 3 4 9 4 8 17 3 4 9 4 9 17 3 4 9 4 9 19 3 4 9 4 9 18 3 4 9 4 9 17 3 4 9 4 9 19 3 4 9 4 1 6)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/26/2008 18:36'!testCode1	| test |	test := MySTLexicalAnalyzerStream on: 'clear: size ^(Interval newFrom: 0 to: size - 1 step: 1) do: [:item| <primitive: 112> value: item].'.	self should: test next = ('clear:' -> #keymessage).	self should: test next = ('size' -> #name).	self should: test next = ('^' -> #token).	self should: test next = ('(' -> #token).	self should: test next = ('Interval' -> #name).	self should: test next = ('newFrom:' -> #keymessage).	self should: test next = ('0' -> #number).	self should: test next = ('to:' -> #keymessage).	self should: test next = ('size' -> #name).	self should: test next = ('-' -> #binmessage).	self should: test next = ('1' -> #number).	self should: test next = ('step:' -> #keymessage).	self should: test next = ('1' -> #number).	self should: test next = (')' -> #token).	self should: test next = ('do:' -> #keymessage).	self should: test next = ('[' -> #token).	self should: test next = ('item' -> #blockarg).	self should: test next = ('|' -> #binmessage).	self should: test next = ('<primitive: 112>' -> #primitive).	self should: test next = ('value:' -> #keymessage).	self should: test next = ('item' -> #name).	self should: test next = (']'->#token).	self should: test next = ('.' -> #token).	self should: test atEnd.! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 10:42'!testCreation	self		should: ((MySTLexicalAnalyzerStream on: 'Object')				isMemberOf: MySTLexicalAnalyzerStream).!]style[(12 2 4 11 1 31 8 45)f2b,f2,f2cmagenta;,f2,f2b,f2,f2c255148000,f2! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:14'!testKeymessage	| test |	test := MySTLexicalAnalyzerStream on: 'at:put: new: Asffggh1234:'.	self should: test next = ('at:' -> #keymessage).	self should: test next = ('put:' -> #keymessage).	self should: test next = ('new:' -> #keymessage).	self should: test next = ('Asffggh1234:' -> #keymessage).	self should: test atEnd.!]style[(14 3 5 4 4 4 25 5 27 3 4 9 4 9 5 4 11 4 4 9 4 9 6 4 11 4 4 9 4 9 6 4 11 4 4 9 4 9 14 4 11 28)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 10:37'!testNumbers	| test |	test := MySTLexicalAnalyzerStream on: ' 	123 0  -123	0.01		1212435436346.009234 		0.987		123 -0.09'.	self should: test next = ('123' -> #number).	self should: test next = ('0' -> #number).	self should: test next = ('-123'-> #number).	self should: test next = ('0.01' -> #float).	self should: test next = ('1212435436346.009234'->#float).	self should: test next = ('0.987' -> #float).	self should: test next = ('123' -> #number).	self should: test next = ('-0.09' -> #float).	self should: test atEnd.!]style[(11 3 5 4 4 4 25 5 65 3 4 9 4 9 17 3 4 9 4 9 15 3 4 9 4 9 17 3 4 22 17 3 4 9 4 9 31 3 4 22 18 3 4 9 4 9 17 3 4 9 4 9 18 3 4 9 4 1 6)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 11:20'!testSimpleAccess	| test |	test := MySTLexicalAnalyzerStream on: '123'.	self should: test next = ('123' -> #number).	self should: test atEnd.!]style[(16 3 5 4 4 4 25 5 5 3 4 9 4 9 17 27)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2! !!MySTLexicalAnalyzerStreamTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/3/2008 10:33'!testWords	| test |	test := MySTLexicalAnalyzerStream on: ' 	Word word  word	word		word				word Word123 '.	self should: test next = ('Word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('word' -> #name).	self should: test next = ('Word123' -> #name).	self should: test atEnd.!]style[(9 3 5 4 4 4 25 5 51 3 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 6 4 5 4 4 9 4 9 9 4 5 28)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2! !SequenceableCollection variableSubclass: #MySTSourceString	instanceVariableNames: 'sourceString tokens testErrorHook'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/6/2008 15:28'!getCallExpression	| expr argoffset |	self canBeCall		ifFalse: [^ nil].	argoffset := 1.	[expr := (self copyFrom: argoffset + 1 to: self size) getKeyArgExpression.	expr		ifNil: [^ nil].	argoffset := expr size + argoffset + 1.	(self valueAt: argoffset) = #keymessage] whileTrue!]style[(17 3 15 4 4 25 3 4 9 4 1 4 4 5 4 11 9 3 1 5 4 29 4 13 3 4 9 4 4 8 9 3 1 4 4 10 10 3 11 11)f2b,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/6/2008 15:01'!getComment	self canBeComment		ifFalse: [^ nil]		ifTrue: [^ self copyFrom: 1 to: 1].!]style[(10 2 4 28 3 40)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/6/2008 15:20'!getExpression	| result |	(result := self getComment)		ifNotNil: [^ result].	(result := self getLocaltemps)		ifNotNil: [^ result].	(result := self getReturnExpression)		ifNotNil: [^ result].	(result := self getName)		ifNotNil: [^ result]!]style[(13 3 7 5 6 4 4 28 6 5 6 4 4 31 6 5 6 4 4 37 6 5 6 4 4 25 6 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/6/2008 14:51'!getLocaltemps	self canBeLocaltemps ifFalse: [^nil].	2 to: self size do: [:index| (self at: index) = '|' ifTrue: [^self copyFrom: 1 to: index]].	^ false.!]style[(45 5 4 95 6)f2b,f2,f2b,f2,f2c255148000! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/6/2008 15:17'!getName	(self valueAt: 1) = #name ifTrue: [^self copyFrom: 1 to: 1] ifFalse: [^nil.].! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/6/2008 15:05'!getReturnExpression	| expr |	self canBeReturn ifFalse: [^nil].	expr := (self copyFrom: 2 to: self size) getExpression.	expr ifNil: [^nil].	^self copyFrom: 1 to: expr size +1.! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/6/2008 17:03'!getUnoCallExpression	self getObject ifNil: [^nil].	(self valueAt: 2) = #name ifTrue: [(self at:3) ifNotNil: [^self copyFrom: 1 to: 3]].	^nil.! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/3/2008 15:01'!initialize: aNumber 	tokens := Array new: aNumber.	sourceString := ''!]style[(12 7 3 6 4 5 6 7 3 12 4 2)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/3/2008 15:13'!replaceFrom: start to: stop with: replacement startingAt: repStart 	| index repOff |	repOff _ repStart - start.	index _ start - 1.	[(index _ index + 1) <= stop]		whileTrue: [tokens at: index put: ((replacement at: repOff + index) -> (replacement valueAt: repOff + index))]! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/1/2008 15:10'!size	^tokens size.! !!MySTSourceString methodsFor: 'accessing' stamp: 'SZ 1/3/2008 15:01'!sourceString: aString 	sourceString := aString.	tokens := (MySTLexicalAnalyzerStream on: aString) asArray.!]style[(14 7 3 12 4 7 3 6 5 25 5 7 10)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2! !!MySTSourceString methodsFor: 'enumerating' stamp: 'SZ 1/1/2008 18:46'!at: aIndex 	^ (tokens		at: aIndex		ifAbsent: [^ nil]) key.!]style[(4 6 6 6 7 6 16 3 7)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cmagenta;,f2! !!MySTSourceString methodsFor: 'enumerating' stamp: 'SZ 1/3/2008 14:11'!valueAt: aIndex 	^ (tokens		at: aIndex		ifAbsent: [^ nil]) value.!]style[(9 6 6 6 7 6 16 3 9)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cmagenta;,f2! !!MySTSourceString methodsFor: 'private' stamp: 'SZ 1/2/2008 11:46'!error: aString	self error: aString with: nil.!]style[(7 7 32 1)f2b,f2cblue;b,f2b,f2! !!MySTSourceString methodsFor: 'private' stamp: 'SZ 1/2/2008 17:54'!error: aString with: data 	testErrorHook		ifNotNil: [(testErrorHook value: aString value: data)				ifFalse: [^ self]].!]style[(7 7 7 4 3 13 15 13 8 7 8 4 18 4 4)f2b,f2cblue;b,f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2! !!MySTSourceString methodsFor: 'private' stamp: 'SZ 1/2/2008 11:47'!errorBlock: aBlock 	testErrorHook := aBlock!]style[(12 6 4 13 4 6)f2b,f2cblue;b,f2,f2cblue;i,f2,f2cblue;i! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 14:42'!canBeAssign	^( self valueAt: 2) = #assign!]style[(11 19 2 3 7)f2b,f2,f2c255146000,f2,f2c255146000! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 16:26'!canBeBinCall	self getObject		ifNil: [^ false].	^ (self valueAt: 2)		= #binmessage!]style[(12 2 4 23 5 7 4 10 1 6 11)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 14:45'!canBeBlock	^ self first = '['!]style[(10 17 3)f2b,f2,f2c255148000! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 14:45'!canBeBracket	^ self first = '('!]style[(12 17 3)f2b,f2,f2c255148000! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 15:29'!canBeCall	^ self getName ifNotNil: [^true] ifNil: [^nil].!]style[(9 4 45)f2b,f2,f2cmagenta;! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 15:01'!canBeComment	^( self valueAt: 1) = #comment.!]style[(12 5 4 15 9)f2b,f2,f2cmagenta;,f2,f2c255147000! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 14:44'!canBeLocaltemps	^ self first = '|'!]style[(15 4 4 9 3)f2b,f2,f2cmagenta;,f2,f2c255148000! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 15:19'!canBeReturn	^ (self first = '^') & (self valueAt: #token).!]style[(11 5 4 9 30)f2b,f2,f2cmagenta;,f2,f2c255148000! !!MySTSourceString methodsFor: 'testing' stamp: 'SZ 1/6/2008 16:25'!canBeUnoCall	self getObject		ifNil: [^ false].	^(self valueAt: 2) = #name!]style[(12 2 4 23 5 6 24)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceString class	instanceVariableNames: ''!!MySTSourceString class methodsFor: 'instance creation' stamp: 'SZ 1/3/2008 15:05'!new: aNumber 	^ super new initialize: aNumber.!]style[(5 7 27 8)f2b,f2cblue;b,f2,f2cblue;i! !!MySTSourceString class methodsFor: 'instance creation' stamp: 'SZ 1/3/2008 15:06'!with: aString 	^ super new initialize: 0; sourceString: aString!]style[(6 7 5 5 34 7)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !!MySTSourceString class methodsFor: 'instance creation' stamp: 'SZ 1/3/2008 15:06'!with: aString withErrorHook: aBlock 	^ super new initialize: 0; errorBlock: aBlock;		sourceString: aString!]style[(6 7 16 6 5 5 32 7 17 7)f2b,f2cblue;b,f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i! !Object subclass: #MySTSourceText	instanceVariableNames: 'sourcetext sourcestring'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTSourceText methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 20:00'!asCompiled	^nil! !!MySTSourceText methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:00'!initializeWith: aString	sourcetext _ aString.	sourcestring _ (MySTLexicalAnalyzerStream on: aString) asOrderedCollection.	^self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceText class	instanceVariableNames: ''!!MySTSourceText class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 18:56'!newFrom: aString	| result |	(result := MySTSourceTextClass newFrom: aString)		ifNotNil: [^result].	(result := MySTSourceTextClassMethods newFrom: aString)		ifNotNil: [^result].	(result := MySTSourceTextMethods newFrom: aString)		ifNotNil: [^result].	^ MySTSourceTextCode newFrom: aString.! !MySTSourceText subclass: #MySTCompiler	instanceVariableNames: 'image bytecode literals temps arguments instances expressions returnedObj'	classVariableNames: 'Image'	poolDictionaries: ''	category: 'MySTCompiler'!!MySTCompiler methodsFor: 'initialize-release' stamp: 'SZ 1/22/2008 21:03'!initializeWith: aString 	super initializeWith: aString.	image _ MySTCompiler currentImage.	expressions _ OrderedCollection new.	self collectExpressions: sourcestring.! !!MySTCompiler methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 15:28'!collectExpressions: aSourceString	| newString |	newString := aSourceString.	[newString first = '.' | ((self whoIs: newString first) = #comment)]		whileTrue: [			newString := newString copyWithoutFirst. 			newString ifEmpty: [^self].].	expressions add: (MySTExpression newFrom: newString) first.	newString := newString copyFrom: expressions last size + 1 to: newString size.		newString isEmpty 		ifTrue: [^self]		ifFalse: [^self collectExpressions: newString].! !!MySTCompiler methodsFor: 'as yet unclassified' stamp: 'SZ 12/31/2007 16:34'!error: aString	self error: aString with: self.!]style[(7 7 33)f2b,f2cblue;b,f2! !!MySTCompiler methodsFor: 'as yet unclassified' stamp: 'SZ 12/31/2007 16:08'!error: aString with: aObject	"error!!!!!!"	aString inspect.	self halt.! !!MySTCompiler methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 20:11'!whoIs: anObject	(anObject isKindOf: MySTExpression) 		ifFalse: [^MySTLexicalAnalyzerStream whatType: anObject] 		ifTrue: [^anObject whatType].! !!MySTCompiler methodsFor: 'evaluating' stamp: 'SZ 1/25/2008 15:15'!compile	literals _ OrderedCollection new.	arguments _ Array new.	temps _ Array new.	instances _ OrderedCollection new.	bytecode _ OrderedCollection new.	expressions do: [:expr | expr compileIn: self].	^self.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 18:23'!callPrimitive: aInteger result: aMySTExpressionUnoCall 	self freeReturnedObj.	self addInstruction: #CALL target: #literals->aInteger.	returnedObj _ aMySTExpressionUnoCall.	aMySTExpressionUnoCall where: #returnedobj->nil.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 18:22'!callPrimitive: aSmallInteger withArgs: anOrderedCollection result: aMySTExpressionKeyCall 	self freeArguments.	1 to: anOrderedCollection size do: [:num| 		self copyToArguments: (anOrderedCollection at: num) position: num - 1.].	self callPrimitive: aSmallInteger result: aMySTExpressionKeyCall.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:25'!clearReturnedObj	returnedObj _ nil.		! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:11'!copyToArguments: aMySTExpression position: aInteger 	self addInstruction: #LD target: #arguments->aInteger source: aMySTExpression where.	arguments size < (aInteger+1)		ifTrue: [arguments _ arguments , (Array new: arguments size - aInteger + 1)].	arguments at: aInteger +1 put: aMySTExpression.	aMySTExpression where: #arguments->aInteger.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:12'!copyToTemps: aMySTExpression position: aInteger 	self addInstruction: #LD target: #temps->aInteger source: aMySTExpression where.	temps size < (aInteger+1)		ifTrue: [temps _ temps , (Array new: temps size - aInteger + 1)].	temps at: aInteger +1 put: aMySTExpression.	aMySTExpression where: #temps->aInteger.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 14:29'!findVariableByName: aString ifAbsent: aBlock	1 to: arguments size do: [:i | (arguments at: i) value = aString ifTrue: [^#arguments->(i - 1)]].	1 to: temps size do: [:i | (temps at: i) value = aString ifTrue: [^#temps->(i - 1)]].	1 to: instances size do: [:i | (instances at: i) value = aString ifTrue: [^#instances->(i - 1)]].	aBlock value.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:30'!freeArguments	^self.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 17:20'!freeReturnedObj	returnedObj 		ifNotNil: [			returnedObj where = (#returnedobj->nil)				ifTrue: [					self copyToTemps: returnedObj position: temps size. returnedObj := nil.]]! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/23/2008 15:20'!return: aMySTExpression	self addInstruction: #RET target: aMySTExpression where.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:28'!send: aMySTExpressionLiteral to: aMySTExpressionObject result: aMySTExpressionCall	self freeReturnedObj.	self 		addInstruction: #SM 		target: aMySTExpressionObject where 		source: aMySTExpressionLiteral where.	returnedObj _ aMySTExpressionCall.	aMySTExpressionCall where: #returnedobj -> nil.! !!MySTCompiler methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:28'!send: aMySTExpressionLiteral to: aMySTExpressionObject withArgs: anOrderedCollection result: aMySTExpressionCall	self freeArguments.	1 to: anOrderedCollection size do: [:num| 		self copyToArguments: (anOrderedCollection at: num) position: num - 1.].	self send: aMySTExpressionLiteral to: aMySTExpressionObject result: aMySTExpressionCall.! !!MySTCompiler methodsFor: 'accessing' stamp: 'SZ 1/21/2008 20:46'!bytecode	^bytecode asArray.! !!MySTCompiler methodsFor: 'old' stamp: 'SZ 1/25/2008 15:13'!addTemp: aMySTExpression position: aInteger 	temps size < (aInteger+1)		ifTrue: [temps _ temps , (Array new: temps size - aInteger + 1)].	temps at: aInteger +1 put: aMySTExpression.	aMySTExpression where: #temps->aInteger.! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/23/2008 15:21'!addInstruction: aSymbol target: anAssociation 	self addInstruction: aSymbol target: anAssociation source: #self->0.! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/23/2008 15:19'!addInstruction: cmd target: trg source: src	|  cmdbyte trgbyte srcbyte |	"cmd"	cmd = #CALL ifTrue: [cmdbyte _ 0].	cmd = #LD ifTrue: [cmdbyte _ 64].	cmd = #SM ifTrue: [cmdbyte _ 128].	cmd = #RET ifTrue: [cmdbyte _ 192].			"trg"	"trg key = #self ifTrue: [cmdbyte _ cmdbyte]."	trg key = #super ifTrue: [cmdbyte _ cmdbyte + 8].	trg key = #returnedobj ifTrue: [cmdbyte _ cmdbyte + 16].	"trg key = #none ifTrue: [cmdbyte _ cmdbyte + 24]."	trg key = #literals ifTrue: [cmdbyte _ cmdbyte + 32. trgbyte _ trg value].	trg key = #temps ifTrue: [cmdbyte _ cmdbyte + 40. trgbyte _ trg value].	trg key = #arguments ifTrue: [cmdbyte _ cmdbyte + 48. trgbyte _ trg value].	trg key = #instances ifTrue: [cmdbyte _ cmdbyte + 56. trgbyte _ trg value].	"src"	"src key = #self ifTrue: [cmdbyte _ cmdbyte + 0]."	src key = #super ifTrue: [cmdbyte _ cmdbyte + 1].	src key = #returnedobj ifTrue: [cmdbyte _ cmdbyte + 2].	"src key = #none ifTrue: [cmdbyte _ cmdbyte + 3]."	src key = #literals ifTrue: [cmdbyte _ cmdbyte + 4. srcbyte _ src value].	src key = #temps ifTrue: [cmdbyte _ cmdbyte + 5. srcbyte _ src value].	src key = #arguments ifTrue: [cmdbyte _ cmdbyte + 6. srcbyte _ src value].	src key = #instances ifTrue: [cmdbyte _ cmdbyte + 7. srcbyte _ src value].	bytecode add: cmdbyte.	trgbyte ifNotNil: [bytecode add: trgbyte].	srcbyte ifNotNil: [bytecode add: srcbyte].		^self! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/23/2008 16:25'!addLiteral: aMySTExpressionObject 	literals add: aMySTExpressionObject.	aMySTExpressionObject where: #literals->(literals size - 1)! !!MySTCompiler methodsFor: 'adding' stamp: 'SZ 1/25/2008 17:10'!addTemp: aMySTExpressionObject 	temps _ temps , (Array with: aMySTExpressionObject).	aMySTExpressionObject where: #temps -> (temps size - 1).	"self addTemp: aMySTExpressionObject position: temps size."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTCompiler class	instanceVariableNames: ''!!MySTCompiler class methodsFor: 'as yet unclassified' stamp: 'SZ 1/10/2008 15:27'!currentImage	^Image.! !!MySTCompiler class methodsFor: 'as yet unclassified' stamp: 'SZ 12/31/2007 16:37'!new	^(super new) initialize.!]style[(3 4 5 18)f2b,f2,f2cmagenta;,f2! !!MySTCompiler class methodsFor: 'as yet unclassified' stamp: 'SZ 1/10/2008 15:26'!setImage: aImage	Image _ aImage.! !!MySTCompiler class methodsFor: 'instance creation' stamp: 'SZ 1/10/2008 15:28'!compile: aString 	^ super new initializeWith: aString; compile.!]style[(9 7 5 5 21 17)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !MySTSourceText subclass: #MySTSourceTextBlock	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextBlock class	instanceVariableNames: ''!!MySTSourceTextBlock class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:29'!newFrom: aString	^nil.! !MySTSourceText subclass: #MySTSourceTextClass	instanceVariableNames: 'classsuper classname classinstvars classvars classpooldict'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTSourceTextClass methodsFor: 'as yet unclassified' stamp: 'SZ 1/26/2008 18:32'!initializeWith: aString	| analizestream |	analizestream _ MySTLexicalAnalyzerStream on: aString.	analizestream next.	classsuper _ analizestream next.	analizestream next = ('subclass:'->#keymessage) ifFalse: [^nil].	classname _ analizestream next.	analizestream next = ('instanceVariableNames:'->#keymessage) ifFalse: [^nil].	classinstvars _ analizestream next.	analizestream next = ('classVariableNames:'->#keymessage) ifFalse: [^nil].	classvars _ analizestream next.	analizestream next = ('poolDictionaries:'->#keymessage) ifFalse: [^nil].	classpooldict _ analizestream next.	^self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextClass class	instanceVariableNames: ''!!MySTSourceTextClass class methodsFor: 'as yet unclassified' stamp: 'SZ 1/26/2008 18:31'!newFrom: aString	| analizestream |	aString first = $!! ifFalse: [^nil].	analizestream _ MySTLexicalAnalyzerStream on: aString.	analizestream next; next.	analizestream next = ('subclass:'->#keymessage) 		ifTrue: [^super new initializeWith: aString] 		ifFalse: [^nil].! !MySTSourceText subclass: #MySTSourceTextClassMethods	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextClassMethods class	instanceVariableNames: ''!!MySTSourceTextClassMethods class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:28'!newFrom: aString	^nil.! !MySTSourceText subclass: #MySTSourceTextCode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTSourceTextCode methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 20:01'!asCompiled	| expressions |	expressions _ OrderedCollection new.! !!MySTSourceTextCode methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:04'!compile	^nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextCode class	instanceVariableNames: ''!!MySTSourceTextCode class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:01'!newFrom: aString	^super new initializeWith: aString.! !MySTSourceText subclass: #MySTSourceTextMethod	instanceVariableNames: 'message args body'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTSourceTextMethod methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:58'!initializeWith: aString	| expr |	super initializeWith: aString.	expr _ (MySTExpression newFrom: (sourcestring copyWithFirst: 'anObject')) first.	(expr isKindOf: MySTExpressionKeyCall) |	(expr isKindOf: MySTExpressionBinCall) |	(expr isKindOf: MySTExpressionUnoCall) 		ifFalse: [^nil].	message _ expr callMessage.	args _ expr callArgs.	body _ sourcestring copyFrom: expr size-1 to: sourcestring size	! !!MySTSourceTextMethod methodsFor: 'accessing' stamp: 'SZ 1/21/2008 19:53'!body	^body.! !!MySTSourceTextMethod methodsFor: 'accessing' stamp: 'SZ 1/26/2008 18:09'!message	^message value.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextMethod class	instanceVariableNames: ''!!MySTSourceTextMethod class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:45'!newFrom: aString	^super new initializeWith: aString.! !MySTSourceText subclass: #MySTSourceTextMethods	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTSourceTextMethods class	instanceVariableNames: ''!!MySTSourceTextMethods class methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:28'!newFrom: aString	^nil.! !TestCase subclass: #MySTSourceTextTestCase	instanceVariableNames: 'text'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:49'!testGetArgsCount	self		should: [(MySTSourceText with: 'isObject ^true.!!') getArgsCount == 0].	self		should: [(MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getArgsCount == 1].	self		should: [(MySTSourceText with: 'at: aNumber put: aObject ^<primitive: 23> value: self value: aNumber value: aObject.!!') getArgsCount == 2]!]style[(16 2 4 13 14 7 18 18 1 4 4 13 14 7 58 18 1 4 4 13 14 7 1 85 1 18 1 1)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 12/25/2007 20:50'!testGetBytecode	self		should: [(MySTSourceText with: 'isObject ^true.!!') getBytecode = #(164 0 1 208 )].	self		should: [(MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getBytecode = #(112 0 117 1 0 32 21 208 )].	self		should: [(MySTSourceText with: '<= aMagnitude ^(self > aMagnitude) not.!!') getBytecode = #(117 0 0 132 0 148 1 208 )]!]style[(15 2 4 13 14 7 18 16 15 4 4 13 14 7 58 16 27 4 4 13 14 7 42 16 27 1)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/26/2008 18:25'!testGetClass	| test |	test _ MySTSourceText newFrom: '!!Object subclass: #Object2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: ''''!!'.	self should: (test isKindOf: MySTSourceTextClass).	self should: test className = 'Object2'.	self should: test classSuper = 'Object'.! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:28'!testGetClassMethods	| srctext meths |	srctext := MySTSourceText with: '!!Object class methods !! new	^<primitive: 11> value: 0.!! new: aSize ^<primitive: 11> value: aSize.!! !!'.	meths := srctext isMethodDefinition.	self		should: [(meths at: 1) isClassMethodDefinition].	self		should: [(meths at: 2) isClassMethodDefinition].	self		should: [(meths at: 1) forClass asString == 'Object'].	self		should: [(meths at: 2) forClass asString == 'Object']!]style[(19 3 14 4 7 4 14 7 102 3 5 4 7 22 4 13 5 5 1 29 4 13 5 5 1 29 4 13 5 5 1 23 8 4 4 13 5 5 1 23 8 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 22:19'!testGetClassVarNames	self		should: [(MySTSourceText with: 'Object subclass: #Object2 instanceVariableNames: ''var1 var2 anyvar OurVar'' classVariableNames: ''ivar1 ivar2 IVar3'' poolDictionaries: ''''!!') getClassVariableNames == #('ivar1' 'ivar2' 'IVar3' ) asOrderedCollection]!]style[(20 2 4 13 14 7 144 27 27 21)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 22:12'!testGetInstVarNames	self		should: [(MySTSourceText with: 'Object subclass: #Object2 instanceVariableNames: ''var1 var2 anyvar OurVar'' classVariableNames: '''' poolDictionaries: ''''!!') getInstanceVariableNames == #('var1' 'var2' 'anyvar' 'OurVar' ) asOrderedCollection]!]style[(19 2 4 13 14 7 127 30 35 21)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 10/20/2007 11:35'!testGetLitSegment	| testLitSeg |	testLitSeg := (MySTSourceText with: 'isObject ^true.!!') getLitSegment.	self		should: [testLitSeg size == 2].	self		should: [(testLitSeg at: 1)				== 'true'].	self		should: [(testLitSeg at: 2)				== 'value'].	testLitSeg := (MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getLitSegment.	self		should: [(testLitSeg at: 1)				== 'value:value:'].	testLitSeg := (MySTSourceText with: '<= aMagnitude ^(self > aMagnitude) not.!!') getLiterals.	self		should: [(testLitSeg at: 1) =='>'].	self should: [(testLitSeg at: 2) == 'not'].!]style[(17 3 11 4 10 5 14 7 18 18 4 12 10 9 1 4 4 13 10 5 1 9 6 4 4 13 10 5 1 9 7 4 10 5 14 7 58 18 4 13 10 5 1 9 14 19 14 7 42 16 4 33 3 47)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2c255147000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:54'!testGetLiterals	self		should: [(MySTSourceText with: 'isObject ^true.!!') getLiterals == #('true' 'value' ) asOrderedCollection].	self		should: [(MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getLiterals == #('value:value:') asOrderedCollection].	self		should: [(MySTSourceText with: '<= aMagnitude ^(self > aMagnitude) not.!!') getLiterals == #('>' 'not')]!]style[(15 2 4 13 14 7 18 17 18 24 4 13 14 7 58 58 4 13 14 7 1 40 1 30)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:49'!testGetMessageString	self		should: [(MySTSourceTextMethod newFrom: 'isObject ^true.!!') message = 'isObject'].	self		should: [(MySTSourceTextMethod newFrom: '== aObject ^<primitive: 21> value: self value: aObject.!!') message = '=='].	self		should: [(MySTSourceTextMethod newFrom: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') message = 'at:'].! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/21/2008 19:54'!testGetMethodBody	self		should: [(MySTSourceTextMethod  newFrom: 'isObject ^true.!!') body = '^true.'].	self		should: [(MySTSourceTextMethod newFrom: '== aObject ^<primitive: 21> value: self value: aObject.!!') body = '^<primitive: 21> value: self value: aObject.'].	self		should: [(MySTSourceTextMethod newFrom: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') body = '^<primitive: 22> value: self value: aNumber.']! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 7/6/2007 20:09'!testGetMethodComments	self		should: [MySTSourceText with: 'at: aNumber put: aObject  "base method at:put:" ^<primitive: 23> value: self value: aNumber value: aObject.!!' getComments == (OrderedCollection with: 'base method at:put:')].!]style[(21 2 4 12 22 25 23 60 64 2)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:27'!testGetMethods	| srctext meths |	srctext := MySTSourceText with: '!!Object methods !! basicAt: aNumber ^<primitive: 19> value: self value: aNumber. !! at: aNumber ^<primitive: 22> value: self value: aNumber.!! !!'.	meths := srctext getMethodDefinitions.	self		should: [(meths at: 1) isMethodDefinition].	self		should: [(meths at: 2) isMethodDefinition].	self		should: [(meths at: 1) forClassInstance asString = 'Object'].	self		should: [(meths at: 2) forClassInstance asString = 'Object']!]style[(14 3 14 4 7 4 14 7 143 3 5 4 7 24 4 13 5 5 1 24 4 13 5 5 1 24 4 13 5 5 1 30 8 4 4 13 5 5 1 30 8 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 22:21'!testGetPoolDictionaries	self		should: [(MySTSourceText with: 'Object subclass: #Object2 instanceVariableNames: ''var1 var2 anyvar OurVar'' classVariableNames: ''ivar1 ivar2 IVar3'' poolDictionaries: ''pool1 pool2 Pool3''!!') getPoolDictionaries == #('pool1' 'pool2' 'Pool3' ) asOrderedCollection]!]style[(23 2 4 13 14 7 161 25 27 21)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 10/20/2007 11:36'!testGetStartTmpSegment	| testArgSeg |	testArgSeg := (MySTSourceText with: 'isObject ^true.!!') getStartTmpSegment.	self		should: [testArgSeg size == 0].	testArgSeg := (MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getStartTmpSegment.	self		should: [testArgSeg size == 1].	self		should: [(testArgSeg at: 1)				== 'aObject'].	testArgSeg := (MySTSourceText with: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') getStartTmpSegment.	self		should: [testArgSeg size == 1].	self		should: [(testArgSeg at: 1)				== 'aNumber'].	testArgSeg := (MySTSourceText with: 'at: aNumber put: aNumber2 ifError: aBlock (<primitive: 22> value: aNumber value: aNumber2) ifFalse: [aBlock value].!!') getStartTmpSegment.	self		should: [testArgSeg size == 3].	self		should: [(testArgSeg at: 1)				== 'aNumber'].	self		should: [(testArgSeg at: 2)				== 'aNumber2'].	self		should: [(testArgSeg at: 3)				== 'aBlock']!]style[(22 3 11 4 10 5 14 7 18 5 15 3 4 12 10 9 1 4 10 5 14 7 58 5 15 3 4 12 10 9 1 4 4 13 10 5 1 9 9 4 10 5 14 7 59 5 15 3 4 12 10 9 1 4 4 13 10 5 1 9 9 4 10 5 14 7 118 5 15 3 4 12 10 9 1 4 4 13 10 5 1 9 9 4 4 13 10 5 1 9 10 4 4 13 10 5 1 9 8 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2b,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 7/6/2007 20:17'!testGetSuperClass	self		should: [(MySTSourceText with: 'Object subclass: #Object2 instanceVariableNames: ''var1 var2 anyvar OurVar'' classVariableNames: '''' poolDictionaries: ''''!!') getClass superClass == 'Object']!]style[(17 2 4 13 14 7 127 25 8 1)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 10/20/2007 11:37'!testGetTmpSegment	| testArgSeg |	testArgSeg := (MySTSourceText with: 'isObject ^true.!!') getArgSerment.	self		should: [testArgSeg size == 0].	testArgSeg := (MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') getArgSegment.	self		should: [testArgSeg size > 0].	self		should: [(testArgSeg at: 1)				== 'aObject'].	testArgSeg := (MySTSourceText with: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') getArgSegment.	self		should: [testArgSeg size > 0].	self		should: [(testArgSeg at: 1)				== 'aNumber'].	testArgSeg := (MySTSourceText with: 'at: aNumber put: aNumber2 ifError: aBlock (<primitive: 22> value: aNumber value: aNumber2) ifFalse: [aBlock value].!!') getArgSegment.	self		should: [testArgSeg size > 2].	self		should: [(testArgSeg at: 1)				== 'aNumber'].	self		should: [(testArgSeg at: 2)				== 'aNumber2'].	self		should: [(testArgSeg at: 3)				== 'aBlock']!]style[(17 3 11 4 10 5 14 7 18 18 4 12 10 9 1 4 10 5 14 7 58 18 4 12 10 8 1 4 4 13 10 5 1 9 9 4 10 5 14 7 59 18 4 12 10 8 1 4 4 13 10 5 1 9 9 4 10 5 14 7 118 18 4 12 10 8 1 4 4 13 10 5 1 9 9 4 4 13 10 5 1 9 10 4 4 13 10 5 1 9 8 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2c255147000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:32'!testIsBinMessageMethod	self		should: [(MySTSourceText with: '== aObject ^<primitive: 21> value: self value: aObject.!!') isBinMessageMethod]!]style[(22 2 4 13 14 7 1 56 1 21)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:01'!testIsClass	self		should: [(MySTSourceText with: 'Object subclass: #Object instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''!!') isClassDefinition]!]style[(11 2 4 13 14 7 97 20)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:17'!testIsClassMethods	self		should: [(MySTSourceText with: '!!Object class methods !! new	^<primitive: 11> value: 0.!! new: aSize ^<primitive: 11> value: aSize.!! !!') isClassMethodsDefinition]!]style[(18 2 4 13 14 7 102 27)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:09'!testIsComment	self		should: [(MySTSourceText with: '"Comments of method or source file"') isComment]!]style[(13 2 4 13 14 7 37 12)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:33'!testIsKeyMessageMethod	self		should: [(MySTSourceText with: 'at: aNumber ^<primitive: 22> value: self value: aNumber.!!') isKeyMessageMethod]!]style[(22 2 4 13 14 7 1 57 1 21)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:02'!testIsMethod	self		should: [(MySTSourceText with: 'isObject ^true.!!') isMethodDefinition]!]style[(12 2 4 13 14 7 18 21)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:17'!testIsMethods	self		should: [(MySTSourceText with: '!!Object methods !! basicAt: aNumber ^<primitive: 19> value: self value: aNumber. !! at: aNumber ^<primitive: 22> value: self value: aNumber.!! !!') isMethodsDefinition]!]style[(13 2 4 13 14 7 143 22)f2b,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTSourceTextTestCase methodsFor: 'as yet unclassified' stamp: 'Saemon Zixel 6/20/2007 21:26'!testIsUnoMessageMethod	self should: [(MySTSourceText with: 'isObject ^true.!!') isUnoMessageMethod].!]style[(22 15 1 1 14 7 39 1)f2b,f2,f2b,f2,f2cmagenta;,f2,f2c255148000,f2! !