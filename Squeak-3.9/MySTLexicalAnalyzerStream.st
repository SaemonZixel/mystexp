'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 7 February 2008 at 10:09:35 pm'!Stream subclass: #MySTLexicalAnalyzerStream	instanceVariableNames: 'sourcetext errormode'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler'!!MySTLexicalAnalyzerStream methodsFor: 'initialize-release' stamp: 'SZ 1/2/2008 21:39'!initialize: aString 	sourcetext := ReadStream on: aString.	errormode := false.!]style[(12 7 3 10 19 29)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:23'!nextTokenAsAssign	sourcetext next = $: & sourcetext atEnd not		ifTrue: [sourcetext peek = $=				ifTrue: [sourcetext next.					^ ':=' -> #assign]]		ifFalse: [sourcetext back].	^nil.!]style[(17 2 10 8 2 3 10 22 10 8 2 14 10 14 4 4 7 15 10 14)f2b,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:21'!nextTokenAsBinMess	| result |	result := ''.	[#($, $- $+ $\ $/ $* $~ $` $= $@ $% $& $? ${ $} $< $> $| ) includes: sourcetext peek]		whileTrue: [result := result , sourcetext next asString.			sourcetext atEnd				ifTrue: [^ result -> #binmessage]].	result = ''		ifTrue: [^ nil]		ifFalse: [^ result -> #binmessage]!]style[(18 3 7 4 6 4 2 4 57 42 6 4 6 64 6 4 11 5 6 3 2 14 3 16 6 4 11 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cblue;i,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 2/4/2008 12:17'!nextTokenAsBlockArg	| result |	result _ ':'.	sourcetext next = $: & sourcetext atEnd not		ifTrue: [sourcetext peek isDigit					ifTrue: [self error: 'no digit in first letter of block arg name!!'. sourcetext next. ^ nil].									sourcetext peek isLetter | (sourcetext peek = $_) ifFalse: [sourcetext back. ^nil. "May be it is assign"].								[sourcetext atEnd not and: [sourcetext peek isAlphaNumeric | (sourcetext peek = $_)]]					whileTrue: [result _ result , sourcetext next asString].									result = ''					ifFalse: [^ result -> #blockarg]].	sourcetext back.	^ nil! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/23/2008 15:40'!nextTokenAsChar	sourcetext peek = '$' last		ifTrue: [sourcetext next.			sourcetext atEnd				ifTrue: [sourcetext back.					^ nil]				ifFalse: [^ ('$', sourcetext next asString) -> #char]].	^nil.! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 2/7/2008 22:02'!nextTokenAsComment	| result |	result := ''.	sourcetext peek = $" ifFalse: [^ nil].	sourcetext next.	[sourcetext atEnd ifTrue: [self error: 'comment can`t end here'. ^'"',result,'"' -> #comment].	sourcetext peek = $" ifTrue: [sourcetext next. ^'"',result,'"' -> #comment].	true]		whileTrue: [result := result , sourcetext next asString].	^ nil! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/26/2008 18:38'!nextTokenAsLiteralOrArray	| result |	result := ''.	sourcetext peek = $#		ifFalse: [^ nil].	sourcetext next.	sourcetext atEnd		ifTrue: [self error: 'literal can`t ending here!!'.			^ nil].	"take literal"	sourcetext peek isLetter		ifTrue: [[result := result , sourcetext next asString.			sourcetext peek isLetter | sourcetext peek isDigit] whileTrue.			^ '#',result -> #literal].	"take array"	sourcetext peek = $(		ifFalse: [self error: 'array no valid!!'.			^ nil].	[sourcetext atEnd		ifTrue: [self error: 'array no valid!!'.			^ nil].	result := result , sourcetext peek asString.	sourcetext next = $)] whileFalse.	sourcetext next.	^ '#',result -> #array! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/3/2008 11:19'!nextTokenAsNameOrKeymess	| result |	result := ''.	sourcetext peek isLetter | (sourcetext peek = $_)		ifTrue: [[sourcetext atEnd not				and: [sourcetext peek isAlphaNumeric | (sourcetext peek = $_)]]				whileTrue: [result := result , sourcetext next asString].			sourcetext peek = $:				ifTrue: [result := result , sourcetext next asString.					^ result -> #keymessage].			result ~= ''				ifTrue: [^ result -> #name]].	^ nil!]style[(24 3 7 4 6 4 2 3 10 18 10 8 2 14 10 21 10 24 10 8 2 20 6 4 6 3 10 20 10 8 2 14 6 4 6 3 10 23 6 4 11 6 6 4 2 16 6 4 5 7 3)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/3/2008 11:24'!nextTokenAsNumber	| result |	result := ''.	"take sign"	(sourcetext next = $- & sourcetext atEnd not			and: [sourcetext peek isDigit])		ifTrue: [result := '-']		ifFalse: [sourcetext back.			sourcetext peek isDigit				ifFalse: [^ nil]].	"take number"	[result := result , sourcetext next asString.	sourcetext atEnd		ifTrue: [^ result -> #number].	sourcetext peek isLetter		ifTrue: [self error: 'Letter in the end of number?'.			^ result -> #number].	sourcetext peek isDigit] whileTrue.	"take float part"	(sourcetext next = $. & sourcetext atEnd not			and: [sourcetext peek isDigit])		ifTrue: [result := result , '.'.			[result := result , sourcetext next asString.			sourcetext atEnd				ifTrue: [^ result -> #float].			sourcetext peek isLetter				ifTrue: [self error: 'Letter in the end of number?'.					^ result -> #float].			sourcetext peek isDigit] whileTrue.			^ result -> #float]		ifFalse: [sourcetext back].	^ result -> #number!]style[(17 3 7 4 6 4 2 3 11 3 10 8 2 3 10 20 10 27 6 4 3 14 10 10 10 30 3 5 13 3 6 4 6 3 10 17 10 20 6 4 7 4 10 26 4 8 30 7 6 4 7 4 10 27 17 3 10 8 2 3 10 20 10 27 6 4 6 3 3 6 6 4 6 3 10 19 10 22 6 4 6 6 10 28 4 8 30 9 6 4 6 6 10 31 6 4 6 14 10 11 6 4 7)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2c147045000,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c147045000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2c147045000,f2,f2cmagenta;,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255147000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255147000,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255147000! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/21/2008 20:59'!nextTokenAsPrimitive	| result |	result := ''.	sourcetext next = $< & sourcetext peek = $p		ifFalse: [sourcetext back.			^ nil].	[sourcetext atEnd		ifTrue: [self error: 'primitive can`t end here'.			^ nil].	sourcetext peek = $>]		whileFalse: [result := result , sourcetext next asString].	sourcetext next.	^ '<',result,'>' -> #primitive! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 1/2/2008 21:26'!nextTokenAsSpecialToken	(#($!! $^ $; $. $[ $] $( $) $: $_ ) includes: sourcetext peek)		ifTrue: [^ sourcetext next asString -> #token]		ifFalse: [^nil].!]style[(23 3 33 11 10 20 10 18 6 20)f2b,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private-nextTokenX' stamp: 'SZ 2/7/2008 21:06'!nextTokenAsString	| result |	result := ''.	sourcetext peek = $'		ifFalse: [^ nil].	sourcetext next.	[sourcetext atEnd		ifTrue: [self error: 'string can`t end here'.			^ '''', result , '''' -> #string].	sourcetext peek = $'		ifTrue: [sourcetext next.			sourcetext peek ~= $'				ifTrue: [^ '''' , result , '''' -> #string]].	true]		whileTrue: [result := result , sourcetext next asString].	^ nil! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 2/7/2008 21:09'!contents	| result |	result := OrderedCollection new.	sourcetext reset.	self do: [:token | result add: token].	^result.! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 1/3/2008 11:27'!next	| result |	errormode		ifTrue: [^ ''].	self trimSpaces.	sourcetext atEnd		ifTrue: [^ nil].	"primitive"	(result := self nextTokenAsPrimitive)		ifNotNil: [^ result].	"number"	(result := self nextTokenAsNumber)		ifNotNil: [^ result].	"block arg"	(result := self nextTokenAsBlockArg)		ifNotNil: [^ result].	"literal or array"	(result := self nextTokenAsLiteralOrArray)		ifNotNil: [^ result].	"char"	(result := self nextTokenAsChar)		ifNotNil: [^ result].	"string"	(result := self nextTokenAsString)		ifNotNil: [^ result].	"comment"	(result := self nextTokenAsComment)		ifNotNil: [^ result].	"assign"	(result := self nextTokenAsAssign)		ifNotNil: [^ result].	"name or keymess"	(result := self nextTokenAsNameOrKeymess)		ifNotNil: [^ result].	"binnary mesage"	(result := self nextTokenAsBinMess)		ifNotNil: [^ result].	"simple tokens"	(result := self nextTokenAsSpecialToken)		ifNotNil: [^ result].	"else error recognision"	self error: 'not recognized!!'.	sourcetext next.	^ self next!]style[(4 3 7 4 9 14 2 4 4 14 10 20 3 4 11 3 6 4 4 38 6 4 8 3 6 4 4 35 6 4 11 3 6 4 4 37 6 4 18 3 6 4 4 43 6 4 6 3 6 4 4 33 6 4 8 3 6 4 4 35 6 16 6 4 4 36 6 4 8 3 6 4 4 35 6 4 17 3 6 4 4 42 6 4 16 3 6 4 4 36 6 4 15 3 6 4 4 41 6 4 24 2 4 8 17 3 10 10 4 5)f2b,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c148046000,f2,f2cmagenta;,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'accessing' stamp: 'SZ 1/28/2008 14:24'!position	^sourcetext position.! !!MySTLexicalAnalyzerStream methodsFor: 'error' stamp: 'SZ 1/2/2008 21:39'!error: aString 	"aString explore.	self halt"	errormode := true.!]style[(7 7 4 7 11 4 26)f2b,f2cblue;b,f2,f2cblue;i,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'testing' stamp: 'SZ 1/3/2008 11:16'!atEnd	self trimSpaces.	^ sourcetext atEnd!]style[(23 4 10 6)f2b,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'private' stamp: 'SZ 2/7/2008 21:35'!trimSpaces	"trim spaces"	[sourcetext atEnd = false and: [sourcetext peek isSeparator]]		whileTrue: [sourcetext next].! !!MySTLexicalAnalyzerStream methodsFor: 'converting' stamp: 'SZ 1/3/2008 15:04'!asArray	^self contents asArray!]style[(7 3 4 17)f2b,f2,f2cmagenta;,f2! !!MySTLexicalAnalyzerStream methodsFor: 'converting' stamp: 'SZ 1/21/2008 19:48'!asOrderedCollection	| result |	result _ OrderedCollection new.	self contents do: [:token| result add: token key].	^result.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTLexicalAnalyzerStream class	instanceVariableNames: ''!!MySTLexicalAnalyzerStream class methodsFor: 'instance creation' stamp: 'SZ 1/2/2008 14:28'!on: aString 	^self basicNew initialize: aString!]style[(4 7 4 4 22 7)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !!MySTLexicalAnalyzerStream class methodsFor: 'converting' stamp: 'SZ 1/19/2008 15:08'!whatType: aString	^(self on: aString) next value.! !