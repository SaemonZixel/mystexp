Object subclass: #MySTExpression	instanceVariableNames: 'whereWeSegment whereWeOffset'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpression methodsFor: 'error' stamp: 'SZ 1/14/2008 19:09'!error	self halt.! !!MySTExpression methodsFor: 'accessing' stamp: 'SZ 1/23/2008 16:13'!whatType	self subclassResponsibility.! !!MySTExpression methodsFor: 'evaluating' stamp: 'SZ 1/19/2008 20:48'!whoIs: anObject	^MySTExpression whoIs: anObject.! !!MySTExpression methodsFor: 'compiling' stamp: 'SZ 1/21/2008 20:30'!where	^whereWeSegment -> whereWeOffset.! !!MySTExpression methodsFor: 'compiling' stamp: 'SZ 1/23/2008 16:22'!where: anAssociation 	whereWeSegment _ anAssociation key.	whereWeOffset _ anAssociation value.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpression class	instanceVariableNames: ''!!MySTExpression class methodsFor: 'as yet unclassified' stamp: 'SZ 1/20/2008 18:27'!canBeCascadeCallIn: aSourceString with: aMySTExpressionCall	^aMySTExpressionCall  size < aSourceString size and: [(aSourceString at: aMySTExpressionCall  size + 1) = ';']! !!MySTExpression class methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 11:34'!getExpression: aSourceString 	| result |	aSourceString size > 1		ifTrue: [(aSourceString first isKindOf: MySTExpressionUnoCall) & (aSourceString second = '|') ifTrue: [^nil]].	(result := MySTExpressionTempsDeclaration newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionReturn newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionAssign newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionCascadeCall newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionKeyCall newFrom: aSourceString)		ifNotNil: [^ result].	^self getExpressionAsKeyCallArg: aSourceString.! !!MySTExpression class methodsFor: 'as yet unclassified' stamp: 'SZ 1/31/2008 20:05'!getExpressionAsBinCallArg: aSourceString	| result |	(result := MySTExpressionUnoCall newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionBlock newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionBracket newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionPrimitive newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionBlockArgument newFrom: aSourceString)		ifNotNil: [^ result].	(result := MySTExpressionObject newFrom: aSourceString)		ifNotNil: [^ result].	^ nil! !!MySTExpression class methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:42'!getExpressionAsKeyCallArg: aSourceString 	| result |	(result := MySTExpressionBinCall newFrom: aSourceString)		ifNotNil: [^ result].	^self getExpressionAsBinCallArg: aSourceString.! !!MySTExpression class methodsFor: 'as yet unclassified' stamp: 'SZ 2/18/2008 15:20'!newExpressionFrom: aSourceString 	| result src |	src _ aSourceString.	[result := self getExpression: src.	result notNil] whileTrue: [	"result size = aSourceString size ifTrue: [^OrderedCollection with: result]."	src := aSourceString allButFirst: result size.	src addFirst: result].	^src! !!MySTExpression class methodsFor: 'as yet unclassified' stamp: 'SZ 1/31/2008 19:33'!newFrom: aSourceString 	| result src |	src := aSourceString.	[result := self getExpression: src.	result		ifNil: [^ src].	result size = aSourceString size		ifTrue: [^ OrderedCollection with: result].	src := aSourceString allButFirst: result size.	src addFirst: result.	true] whileTrue! !!MySTExpression class methodsFor: 'evaluating' stamp: 'SZ 1/21/2008 20:11'!whoIs: anObject	(anObject isKindOf: MySTExpression) 		ifFalse: [^MySTLexicalAnalyzerStream whatType: anObject] 		ifTrue: [^anObject whatType].! !MySTExpression subclass: #MySTExpressionAssign	instanceVariableNames: 'assignexpr receiver'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionAssign methodsFor: 'initialize-release' stamp: 'SZ 1/19/2008 21:40'!initializeWith: aSourceString 	receiver := aSourceString first.	assignexpr := (MySTExpression				newFrom: (aSourceString copyFrom: 3 to: aSourceString size)) first.! !!MySTExpressionAssign methodsFor: 'accessing' stamp: 'SZ 1/19/2008 20:53'!assignExpression	^assignexpr.! !!MySTExpressionAssign methodsFor: 'accessing' stamp: 'SZ 1/19/2008 20:53'!assignTarget	^receiver.! !!MySTExpressionAssign methodsFor: 'accessing' stamp: 'SZ 1/19/2008 20:52'!size	^ receiver size + assignexpr size + 1! !!MySTExpressionAssign methodsFor: 'accessing' stamp: 'SZ 1/19/2008 15:44'!whatType	^ #assignexpr!]style[(8 4 11)f2b,f2,f2c255148000! !!MySTExpressionAssign methodsFor: 'accessing' stamp: 'SZ 2/5/2008 13:00'!where	^self assignTarget where.! !!MySTExpressionAssign methodsFor: 'compiling' stamp: 'SZ 2/5/2008 12:48'!compileIn: aMySTCompiledMethod 	receiver compileIn: aMySTCompiledMethod.	assignexpr compileIn: aMySTCompiledMethod.	aMySTCompiledMethod assign: assignexpr to: receiver.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionAssign class	instanceVariableNames: ''!!MySTExpressionAssign class methodsFor: 'instance creation' stamp: 'SZ 2/4/2008 12:01'!newFrom: aSourceString 	aSourceString size < 2 ifTrue: [^nil].	((self whoIs: aSourceString first) = #object) 		& ((aSourceString second = ':=') | (aSourceString second = '_')) 			ifFalse: [^nil] 			ifTrue: [^super new initializeWith: aSourceString].! !MySTExpression subclass: #MySTExpressionBlock	instanceVariableNames: 'args expressions sizecorection compiled'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionBlock methodsFor: 'accessing' stamp: 'SZ 2/10/2008 17:20'!argCount	^args size.! !!MySTExpressionBlock methodsFor: 'accessing' stamp: 'SZ 1/30/2008 21:07'!arguments	^args! !!MySTExpressionBlock methodsFor: 'accessing' stamp: 'SZ 1/14/2008 20:41'!blockArgs	^args.! !!MySTExpressionBlock methodsFor: 'accessing' stamp: 'SZ 1/14/2008 20:40'!blockExpressions	^expressions! !!MySTExpressionBlock methodsFor: 'accessing' stamp: 'SZ 1/30/2008 21:04'!expressions	^expressions.! !!MySTExpressionBlock methodsFor: 'accessing' stamp: 'SZ 1/21/2008 10:19'!size	| result |	result := 2.	args  size >0 ifTrue: [result _ result + 1 + args size].	expressions do: [:expr| result _ result + expr size].	^result + sizecorection.! !!MySTExpressionBlock methodsFor: 'accessing' stamp: 'SZ 2/10/2008 17:21'!tmpCount	^compiled temps size.! !!MySTExpressionBlock methodsFor: 'accessing' stamp: 'SZ 1/19/2008 15:41'!whatType	^#blockexpr.!]style[(11 11)f2,f2c255148000! !!MySTExpressionBlock methodsFor: 'initialize-release' stamp: 'SZ 1/31/2008 20:11'!collectArguments: aSourceString 	(self whoIs: aSourceString first) = #blockarg		ifTrue: [args add: (MySTExpressionBlockArgument newFrom: (aSourceString first: 1)).			^ self collectArguments: aSourceString copyWithoutFirst]! !!MySTExpressionBlock methodsFor: 'initialize-release' stamp: 'SZ 1/21/2008 10:25'!collectExpressions: aSourceString 	| newString |	newString := aSourceString.	[newString first = '.' | ((self whoIs: newString first) = #comment)]		whileTrue: [newString := newString copyWithoutFirst. sizecorection _ sizecorection + 1].	newString first = ']'		ifTrue: [^ self].	expressions add: (MySTExpression newFrom: newString) first.	newString := newString copyFrom: expressions last size + 1 to: newString size.	^ self collectExpressions: newString! !!MySTExpressionBlock methodsFor: 'initialize-release' stamp: 'SZ 1/21/2008 10:19'!initializeWith: aSourceString 	expressions := OrderedCollection new.	sizecorection _ 0.	args := OrderedCollection new.	self collectArguments: aSourceString copyWithoutFirst .	args size > 0		ifTrue: [self				collectExpressions: (aSourceString copyFrom: args size + 3 to: aSourceString size)]		ifFalse: [self				collectExpressions: (aSourceString copyFrom: 2 to: aSourceString size)]! !!MySTExpressionBlock methodsFor: 'compiling' stamp: 'SZ 1/31/2008 20:18'!bytecode	compiled 		ifNotNil: [^compiled bytecode]		ifNil: [nil].! !!MySTExpressionBlock methodsFor: 'compiling' stamp: 'SZ 2/2/2008 12:53'!compileIn: aMySTCompiledMethodOrBlock	aMySTCompiledMethodOrBlock addLiteral: self.	aMySTCompiledMethodOrBlock 		callPrimitive: 9 		withArgs: (OrderedCollection with: self) 		result: self.		compiled _ MySTCompiledBlock newFrom: self.	aMySTCompiledMethodOrBlock addPostCompile: [:methodorblock | compiled compile: methodorblock].			! !!MySTExpressionBlock methodsFor: 'compiling' stamp: 'SZ 1/31/2008 20:18'!literals	compiled 		ifNotNil: [^compiled literals]		ifNil: [^nil].! !!MySTExpressionBlock methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 12:52'!temps	^compiled temps.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionBlock class	instanceVariableNames: ''!!MySTExpressionBlock class methodsFor: 'instance creation' stamp: 'SZ 1/19/2008 21:10'!newFrom: aSourceString 	aSourceString first = '[' ifFalse: [^nil]	ifTrue: [^super new initializeWith: aSourceString].! !MySTExpression subclass: #MySTExpressionBracket	instanceVariableNames: 'expressions'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionBracket methodsFor: 'accessing' stamp: 'SZ 1/10/2008 15:49'!expressions	^expressions.! !!MySTExpressionBracket methodsFor: 'accessing' stamp: 'SZ 1/19/2008 20:52'!size	| result |	result := 2.	expressions		do: [:expr | result := result + expr size].	^ result! !!MySTExpressionBracket methodsFor: 'accessing' stamp: 'SZ 1/19/2008 15:42'!whatType	^#bracketexpr.!]style[(11 13)f2,f2c255148000! !!MySTExpressionBracket methodsFor: 'accessing' stamp: 'SZ 2/4/2008 11:58'!where	^expressions last where.! !!MySTExpressionBracket methodsFor: 'initialize-release' stamp: 'SZ 1/19/2008 20:42'!initializeWith: aSourceString	| temp expr |	expressions _ OrderedCollection new.	temp _ aSourceString copyFrom: 2 to: aSourceString size.	[temp first = ')'] whileFalse:	[expr _ MySTExpression newFrom: temp.	expressions add: expr first.	temp _ temp copyFrom: expressions last size + 1 to: temp size.].	^self.! !!MySTExpressionBracket methodsFor: 'compiling' stamp: 'SZ 2/4/2008 11:57'!compileIn: aMySTCompiledMethod 	expressions do: [:exp | exp compileIn: aMySTCompiledMethod].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionBracket class	instanceVariableNames: ''!!MySTExpressionBracket class methodsFor: 'instance creation' stamp: 'SZ 1/19/2008 20:41'!newFrom: aSourceString 	aSourceString first = '(' ifFalse: [^nil]	ifTrue: [^super new initializeWith: aSourceString].! !MySTExpression subclass: #MySTExpressionCascadeCall	instanceVariableNames: 'callexpression'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionCascadeCall methodsFor: 'creation' stamp: 'SZ 1/23/2008 16:45'!initializeWith: aSourceString	callexpression _ aSourceString first.	^self.! !!MySTExpressionCascadeCall methodsFor: 'accessing' stamp: 'SZ 1/20/2008 17:28'!callTarget	^callexpression.! !!MySTExpressionCascadeCall methodsFor: 'accessing' stamp: 'SZ 1/20/2008 17:13'!size	^callexpression size + 1.! !!MySTExpressionCascadeCall methodsFor: 'accessing' stamp: 'SZ 1/19/2008 22:05'!whatType	^#cascadecall.! !!MySTExpressionCascadeCall methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:29'!compileIn: aMySTCompiledMethodOrBlock 	callexpression compileIn: aMySTCompiledMethodOrBlock.	aMySTCompiledMethodOrBlock clearReturnedObj.! !!MySTExpressionCascadeCall methodsFor: 'compiling' stamp: 'SZ 1/25/2008 16:01'!where	^callexpression callTarget where.! !!MySTExpressionCascadeCall methodsFor: 'compiling' stamp: 'SZ 1/25/2008 16:01'!where: anAssociation 	^callexpression callTarget where: anAssociation.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionCascadeCall class	instanceVariableNames: ''!!MySTExpressionCascadeCall class methodsFor: 'instance creation' stamp: 'SZ 1/23/2008 16:44'!newFrom: aSourceString 	aSourceString size > 1 		ifTrue: [			(#(#unocallexpr #keycallexpr #bincallexpr  ) includes: (self whoIs: aSourceString first))			& (aSourceString second = ';')				ifTrue: [^ super new initializeWith: aSourceString]].	^nil.! !MySTExpression subclass: #MySTExpressionObject	instanceVariableNames: 'value whereWeTrueObject'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionObject methodsFor: 'accessing' stamp: 'SZ 1/22/2008 19:12'!size	^1.! !!MySTExpressionObject methodsFor: 'accessing' stamp: 'SZ 1/22/2008 19:22'!value	^value.! !!MySTExpressionObject methodsFor: 'accessing' stamp: 'SZ 1/22/2008 19:11'!whatType	^#object.!]style[(8 3 8)f2b,f2,f2c255146000! !!MySTExpressionObject methodsFor: 'accessing' stamp: 'SZ 1/30/2008 20:17'!where	whereWeTrueObject 		ifNotNil: [^whereWeTrueObject where]		ifNil: [^super where].! !!MySTExpressionObject methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 12:12'!initializeWith: aString	value _ aString.! !!MySTExpressionObject methodsFor: 'as yet unclassified' stamp: 'SZ 1/31/2008 20:03'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream print: self value.	aStream nextPut: $)! !!MySTExpressionObject methodsFor: 'compiling' stamp: 'SZ 1/30/2008 20:35'!compileAsAvailableVariableIn: aMySTCompiledMethodOrBlock	whereWeTrueObject _ aMySTCompiledMethodOrBlock findVariableByName: self value ifAbsent: [self error: 'not found !!?'. nil].! !!MySTExpressionObject methodsFor: 'compiling' stamp: 'SZ 2/4/2008 18:49'!compileAsGlobalIn: aMySTCompiledMethodOrBlock	|  litvalue | 	litvalue _ MySTExpressionLiteral newFrom: #('value').	aMySTCompiledMethodOrBlock addLiteral: self.	aMySTCompiledMethodOrBlock addLiteral: litvalue.	aMySTCompiledMethodOrBlock send: litvalue to: self withArgs: nil result: self.! !!MySTExpressionObject methodsFor: 'compiling' stamp: 'SZ 1/31/2008 20:02'!compileIn: aMySTCompiledMethodOrBlock	|  type |	type _ self whoIs: value.	type = #name 		ifTrue: [			value = 'self' ifTrue: [whereWeSegment := #self. ^self].			value = 'super' ifTrue: [whereWeSegment := #super. ^self].			value first isUppercase 				ifTrue: [self compileAsGlobalIn: aMySTCompiledMethodOrBlock]				ifFalse: [(aMySTCompiledMethodOrBlock findVariableByName: self value ifAbsent: [nil])							ifNil: [self compileAsGlobalIn: aMySTCompiledMethodOrBlock]							ifNotNil: [self compileAsAvailableVariableIn: aMySTCompiledMethodOrBlock].					].			].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionObject class	instanceVariableNames: ''!!MySTExpressionObject class methodsFor: 'instance creation' stamp: 'SZ 2/9/2008 12:12'!newFrom: aSourceString 	(self whoIs: aSourceString first) = #name		ifTrue: [^ super new initializeWith: aSourceString first]		ifFalse: [^MySTExpressionLiteral newFrom: aSourceString].! !!MySTExpressionObject class methodsFor: 'instance creation' stamp: 'SZ 2/9/2008 12:11'!withName: aString 	^ super new initializeWith: aString.! !MySTExpressionObject subclass: #MySTExpressionBlockArgument	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionBlockArgument methodsFor: 'as yet unclassified' stamp: 'SZ 1/31/2008 20:03'!compileIn: aMySTCompiledMethodOrBlock	aMySTCompiledMethodOrBlock addArgument: self.! !!MySTExpressionBlockArgument methodsFor: 'as yet unclassified' stamp: 'SZ 1/31/2008 20:04'!value	^value allButFirst: 1.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionBlockArgument class	instanceVariableNames: ''!!MySTExpressionBlockArgument class methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 12:17'!newFrom: aSourceString 	(self whoIs: aSourceString first) = #blockarg		ifTrue: [^ super new initializeWith: aSourceString first]		ifFalse: [^ nil].! !MySTExpressionObject subclass: #MySTExpressionLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionLiteral methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:23'!compileIn: aMySTCompiledMethodOrBlock	aMySTCompiledMethodOrBlock addLiteral: self.! !!MySTExpressionLiteral methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 20:49'!literalType	| type |	type _ self whoIs: value.	(#(#string #number #char) includes: type)		ifTrue: [^type].		(#(#keymessage #name #binmessage) includes: type)		ifTrue: [^#symbol].! !!MySTExpressionLiteral methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 20:55'!value	value first = $'		ifTrue: [^value copyFrom: 2 to: value size - 1].	value first = $$		ifTrue: [^value second].			^super value.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionLiteral class	instanceVariableNames: ''!!MySTExpressionLiteral class methodsFor: 'as yet unclassified' stamp: 'SZ 2/9/2008 12:17'!newFrom: aSourceString 	(#( #number #char #string #keymessage #name #binmessage) includes: (self whoIs: aSourceString first))		ifFalse: [^ nil].	^ super new initializeWith: aSourceString first.! !MySTExpression subclass: #MySTExpressionPrimitive	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionPrimitive methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 17:59'!initializeWith: aSourceString	number _ aSourceString first copyFrom: '<primitive:' size+1 to: aSourceString first size-1.	number _ number asInteger.! !!MySTExpressionPrimitive methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 17:57'!size	^1.! !!MySTExpressionPrimitive methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 17:57'!whatType	^#primitivecall! !!MySTExpressionPrimitive methodsFor: 'accessing' stamp: 'SZ 1/25/2008 17:58'!primitiveNumber	^number.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionPrimitive class	instanceVariableNames: ''!!MySTExpressionPrimitive class methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 17:47'!newFrom: aSourceString 	#primitive = (self whoIs: aSourceString first)		ifTrue: [^ super new initializeWith: aSourceString]		ifFalse: [^nil].! !MySTExpression subclass: #MySTExpressionReturn	instanceVariableNames: 'returnexpr'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionReturn methodsFor: 'accessing' stamp: 'SZ 1/19/2008 21:02'!returnExpression	^ returnexpr.! !!MySTExpressionReturn methodsFor: 'accessing' stamp: 'SZ 1/19/2008 21:01'!size	^ 1 + returnexpr size! !!MySTExpressionReturn methodsFor: 'accessing' stamp: 'SZ 2/4/2008 13:15'!where	^#returnedobj->nil.! !!MySTExpressionReturn methodsFor: 'initialize-release' stamp: 'SZ 2/18/2008 15:15'!initializeWith: aSourceString 	returnexpr := (MySTExpression				newFrom: (aSourceString allButFirst: 1)) first.! !!MySTExpressionReturn methodsFor: 'evaluating' stamp: 'SZ 1/19/2008 15:15'!whatType	^#returnexpr.!]style[(11 12)f2,f2c255147000! !!MySTExpressionReturn methodsFor: 'compiling' stamp: 'SZ 1/21/2008 20:25'!compileIn: aMySTMethodOrBlock	returnexpr compileIn: aMySTMethodOrBlock.	aMySTMethodOrBlock return: returnexpr.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionReturn class	instanceVariableNames: ''!!MySTExpressionReturn class methodsFor: 'as yet unclassified' stamp: 'SZ 1/19/2008 20:56'!newFrom: aSourceString 	aSourceString first = '^'		ifTrue: [^ super new initializeWith: aSourceString]		ifFalse: [^ nil]! !MySTExpression subclass: #MySTExpressionTempsDeclaration	instanceVariableNames: 'temps'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionTempsDeclaration methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:10'!collectNames: aSourceString	(self whoIs: aSourceString first) = #name		ifTrue: [			temps add: (MySTExpressionObject newFrom: (OrderedCollection with: aSourceString first)).			^self collectNames: aSourceString copyWithoutFirst].! !!MySTExpressionTempsDeclaration methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:03'!initializeWith: aSourceString 	temps _ OrderedCollection new.	self collectNames: aSourceString copyWithoutFirst.	(aSourceString at: temps size +2) = '|' 		ifFalse: [^nil]		ifTrue: [^self].	! !!MySTExpressionTempsDeclaration methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:14'!whatType	^#temps! !!MySTExpressionTempsDeclaration methodsFor: 'accessing' stamp: 'SZ 1/23/2008 16:03'!size	^2 + temps size.! !!MySTExpressionTempsDeclaration methodsFor: 'accessing' stamp: 'SZ 1/23/2008 16:14'!temps	^temps! !!MySTExpressionTempsDeclaration methodsFor: 'compiling' stamp: 'SZ 1/23/2008 16:19'!compileIn: aMySTCompiledMethodOrBlock	temps do: [:temp| aMySTCompiledMethodOrBlock addTemp: temp].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionTempsDeclaration class	instanceVariableNames: ''!!MySTExpressionTempsDeclaration class methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 15:54'!newFrom: aSourceString 	aSourceString first = '|'		ifTrue: [^ super new initializeWith: aSourceString]		ifFalse: [^ nil]! !TestCase subclass: #MySTExpressionTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/19/2008 19:34'!testExpressionAssign	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: 'temp'						with: ':='						with: '1').	self should: test isSequenceable.	test := test first.	self		should: (test isKindOf: MySTExpressionAssign).	self		should: (test assignTarget isKindOf: MySTExpressionObject).	self		should: (test assignExpression isKindOf: MySTExpressionObject).	self should: test size = 3!]style[(20 3 5 4 4 4 14 25 17 13 6 13 4 13 3 4 4 9 4 18 4 4 4 9 4 12 4 11 20 4 4 12 4 24 20 4 4 12 4 28 20 4 4 9 4 8 1)f2b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2c255148000,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:04'!testExpressionBinCall	| test test2 |	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: '1'						with: '+'						with: '1').	self should: test isSequenceable.	test := test first.	self should: (test isKindOf: MySTExpressionBinCall).	self should: (test callTarget isKindOf: MySTExpressionObject).	self should: test callMessage value = '+'.	self should: test callArgs size = 1.	self should: (test callArgs first isKindOf: MySTExpressionObject).	self should: test size = 3.	test2 := MySTExpression				newExpressionFrom: (OrderedCollection						with: '1'						with: '+'						with: '1'						with: '-'						with: '1').	self should: test2 isSequenceable.	test2 := test2 first.	self should: (test2 isKindOf: MySTExpressionBinCall).	self should: (test2 callTarget isKindOf: MySTExpressionBinCall).	self should: test2 callMessage value = '-'.	self should: test2 callArgs size = 1.	self should: (test2 callArgs first isKindOf: MySTExpressionObject).	self should: test2 size = 5.	test2 := MySTExpression				newExpressionFrom: (OrderedCollection						with: '<primitive: 709>'						with: '+'						with: '1'						with: '-'						with: '1').	self should: test2 isSequenceable.	test2 := test2 first.	self should: (test2 isKindOf: MySTExpressionPrimitive).! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/31/2008 20:09'!testExpressionBlock	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: '['						with: 'a'						with: ']').	self should: test isSequenceable.	test := test first.	self should: (test isKindOf: MySTExpressionBlock).	self should: test blockExpressions size = 1.	self should: (test blockExpressions first isKindOf: MySTExpressionObject).	self should: test blockArgs size = 0.	self should: test size = 3.	test := MySTExpression newExpressionFrom: (OrderedCollection new add: '[';					 add: ':a';					 add: ':b';					 add: '|';					 add: 'a';					 add: ']';					 value).	self should: test isSequenceable.	test := test first.	self should: (test isKindOf: MySTExpressionBlock).	self should: test blockExpressions size = 1.	self should: (test blockExpressions first isKindOf: MySTExpressionObject).	self should: test blockArgs size = 2.	self should: (test blockArgs first isKindOf: MySTExpressionObject).	self should: (test blockArgs last isKindOf: MySTExpressionObject).	self should: test size = 6.	test := MySTExpression newExpressionFrom: (OrderedCollection new add: '[';					 add: ':a';					 add: ':b';					 add: '|';					 add: 'a';					 add: '>';					 add: 'b';					 add: 'ifTrue:';					 add: '[';					 add: '^';					 add: 'a';					 add: ']';					 add: 'ifFalse:';					 add: '[';					 add: '^';					 add: 'b';					 add: ']';					 add: '.';					 add: '"prikol"';					 add: '^';					 add: 'nil';					 add: '.';					 add: '^';					 add: 'self';					 add: 'halt';					 add: ']';					 value).	self should: test isSequenceable.	test := test first.	self should: (test isKindOf: MySTExpressionBlock).	self should: test blockArgs size = 2.	self should: (test blockArgs first isKindOf: MySTExpressionObject).	self should: (test blockArgs last isKindOf: MySTExpressionObject).	self should: test blockExpressions size = 3.	self should: (test blockExpressions first isKindOf: MySTExpressionKeyCall).	self should: test size = 26.	! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/19/2008 20:27'!testExpressionBraket	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: '('						with: '1'						with: ')').	self should: (test isSequenceable).	test _ test first.	self		should: (test isKindOf: MySTExpressionBracket).	self		should: (test expressions first isKindOf: MySTExpressionObject).	self should: test size = 3! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:39'!testExpressionCascadeCall	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: 'Object'						with: 'class'						with: ';'						with: 'new').	self should: test isSequenceable.	test := test first.	self should: test size = 4.	self		should: (test isKindOf: MySTExpressionUnoCall).	self		should: (test callTarget isKindOf: MySTExpressionCascadeCall).	self should: (test callTarget callTarget isKindOf: MySTExpressionUnoCall).	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: '1'						with: '+'						with: '1'						with: ';'						with: '-'						with: '1').	self should: test isSequenceable.	test := test first.	self should: test size = 6.	self		should: (test isKindOf: MySTExpressionBinCall).	self		should: (test callTarget isKindOf: MySTExpressionCascadeCall).	self should: (test callTarget callTarget isKindOf: MySTExpressionBinCall).	test := MySTExpression newExpressionFrom: (OrderedCollection new add: 'Array';					 add: 'new:';					 add: '1';					 add: ';';					 add: 'at:';					 add: '1';					 add: 'put:';					 add: '1';					 value).	self should: test isSequenceable.	test := test first.	self should: test size = 8.	self		should: (test isKindOf: MySTExpressionKeyCall).	self		should: (test callTarget isKindOf: MySTExpressionCascadeCall ).	self should: (test callTarget callTarget isKindOf: MySTExpressionKeyCall ).	test := MySTExpression newExpressionFrom: (OrderedCollection new add: '''text''';					 add: 'clone';					 add: 'at:';				 	 add: '1';					 add: 'put:';					 add: '$T';					 add: ';';					 add: 'printOn:';					 add: 'Transcript';					 add: 'new';					 value).	self should: test isSequenceable.	test := test first.	self should: test size = 10.	self		should: (test isKindOf: MySTExpressionKeyCall).	self		should: (test callTarget isKindOf: MySTExpressionCascadeCall ).	self should: (test callTarget callTarget isKindOf: MySTExpressionKeyCall ).! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/18/2008 15:23'!testExpressionCode1	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection new 						add: '^';						add: 'self';						add: '==';						add: 'aSmallInt';						add: 'asSmallInteger';						add: '.';						value).	self should: test isSequenceable.	self should: test size = 2.	test := test first.	self should: (test isKindOf: MySTExpressionReturn).	self should: (test returnExpression isKindOf: MySTExpressionBinCall).	self should: (test returnExpression callArgs first isKindOf: MySTExpressionUnoCall).! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 2/18/2008 15:52'!testExpressionCode2	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection new 						add: 'self';						add: '>';						add: '(';						add: '0';						add: '-';						add: '127';						add: ')';						add: 'ifTrue:';						add: '[';						add: '^';						add: 'self';						add: 'basciAt:';						add: '1';						add: ']';						add: '.';						value).	self should: test isSequenceable.	self should: test size = 2.	test := test first.	self should: (test isKindOf: MySTExpressionKeyCall).	self should: (test callArgs first isKindOf: MySTExpressionBlock).	self should: (test callTarget isKindOf: MySTExpressionBinCall).	self should: (test callTarget callTarget value = 'self').	self should: (test callTarget callArgs first isKindOf: MySTExpressionBracket).! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:06'!testExpressionKeyCall	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: 'Object'						with: 'new:'						with: '1').	self should: test isSequenceable.	test := test first.	self should: (test isKindOf: MySTExpressionKeyCall).	self should: (test callTarget isKindOf: MySTExpressionObject).	self should: test callMessage value = 'new:'.	self should: test callArgs size = 1.	self should: (test callArgs first isKindOf: MySTExpressionObject).	self should: test size = 3.	test := MySTExpression newExpressionFrom: (OrderedCollection new add: '''123''';					 add: 'at:';					 add: '1';					 add: '+';					 add: 'arg1';					 add: 'put:';					 add: '$+';					 add: 'ifError:';					 add: '[';					 add: '^';					 add: 'nil';					 add: ']';					 add: '.';					 value).	self should: test isSequenceable.	test := test first.	self should: (test isKindOf: MySTExpressionKeyCall).	self should: (test callTarget isKindOf: MySTExpressionObject).	self should: test callMessage value = 'at:put:ifError:'.	self should: test callArgs size = 3.	self should: ((test callArgs at: 1) isKindOf: MySTExpressionBinCall).	self should: ((test callArgs at: 2) isKindOf: MySTExpressionObject).	self should: ((test callArgs at: 3) isKindOf: MySTExpressionBlock).	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: '<primitive: 0>'						with: 'value:'						with: '1'						with: 'value:'						with: '2').	self should: test isSequenceable.	test := test first.	self should: (test isKindOf: MySTExpressionKeyCall).	self should: (test callTarget isKindOf: MySTExpressionPrimitive).	self should: test callMessage value = 'value:value:'.	self should: test callArgs size = 2.	self should: (test callArgs first isKindOf: MySTExpressionObject).	self should: (test callArgs second isKindOf: MySTExpressionObject).	self should: test size = 5.! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/19/2008 20:33'!testExpressionObject	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection with: 'self').	self should: (test isSequenceable).	test _ test first.	self		should: (test isKindOf: MySTExpressionObject).	self should: test size = 1! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 17:50'!testExpressionPrimitive	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection with: '<primitive: 1>').	self should: (test isSequenceable).	test _ test first.	self should: (test isKindOf: MySTExpressionPrimitive).	self should: test primitiveNumber = 1.			self should: test size = 1! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/19/2008 20:33'!testExpressionReturn	| test |	test := MySTExpression				newExpressionFrom: (OrderedCollection with: '^' with: 'self').	self should: (test isSequenceable).	test _ test first.	self		should: (test isKindOf: MySTExpressionReturn).	self		should: (test returnExpression isKindOf: MySTExpressionObject).	self should: test size = 2.	test := MySTExpression				newExpressionFrom: (OrderedCollection						with: '^'						with: 'super'						with: 'new').	self should: (test isSequenceable).	test _ test first.	self		should: (test isKindOf: MySTExpressionReturn).	self		should: (test returnExpression isKindOf: MySTExpressionUnoCall).	self should: test size = 3! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/23/2008 16:08'!testExpressionTemps	| test |	test := MySTExpression newExpressionFrom: (OrderedCollection with: '|' with: 'a' with: 'b' with: '|').	self should: (test isSequenceable).	test _ test first.	self should: (test isKindOf: MySTExpressionTemps).	self should: test size = 4.	self should: test temps size = 2.	self should: ((test temps at: 1) isKindOf: MySTExpressionObject).	self should: ((test temps at: 2) isKindOf: MySTExpressionObject).	test := MySTExpression newExpressionFrom: (OrderedCollection with: '|' with: '|').	self should: (test isSequenceable).	test _ test first.	self should: (test isKindOf: MySTExpressionTemps).	self should: test size = 2.	self should: test temps size = 0.! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 17:56'!testExpressionTempsDeclaration	| test |	test := MySTExpression newExpressionFrom: (OrderedCollection with: '|' with: 'a' with: 'b' with: '|').	self should: (test isSequenceable).	test _ test first.	self should: (test isKindOf: MySTExpressionTempsDeclaration).	self should: test size = 4.	self should: test temps size = 2.	self should: ((test temps at: 1) isKindOf: MySTExpressionObject).	self should: ((test temps at: 2) isKindOf: MySTExpressionObject).	test := MySTExpression newExpressionFrom: (OrderedCollection with: '|' with: '|').	self should: (test isSequenceable).	test _ test first.	self should: (test isKindOf: MySTExpressionTempsDeclaration).	self should: test size = 2.	self should: test temps size = 0.! !!MySTExpressionTestCase methodsFor: 'as yet unclassified' stamp: 'SZ 1/25/2008 18:02'!testExpressionUnoCall	| test test2 |	test := MySTExpression				newExpressionFrom: (OrderedCollection with: 'temp' with: 'new').	self should: (test isSequenceable).	test _ test first.	self should: (test isKindOf: MySTExpressionUnoCall).	self should: (test callTarget isKindOf: MySTExpressionObject).	self should: test callMessage value = 'new'.	self should: test callArgs = nil.	self should: test size = 2.	test2 := MySTExpression				newExpressionFrom: (OrderedCollection						with: 'temp'						with: 'new'						with: 'clone').	self should: (test2 isSequenceable).	test2 _ test2 first.	self should: (test2 isKindOf: MySTExpressionUnoCall).	self should: (test2 callTarget isKindOf: MySTExpressionUnoCall).	self should: test2 callMessage value = 'clone'.	self should: test2 callArgs = nil.	self should: test2 size = 3.		test2 := MySTExpression				newExpressionFrom: (OrderedCollection						with: '<primitive: 99>'						with: 'value').	self should: (test2 isSequenceable).	test2 _ test2 first.	self should: (test2 isKindOf: MySTExpressionUnoCall).	self should: (test2 callTarget isKindOf: MySTExpressionPrimitive).	self should: test2 callMessage value = 'value'.	self should: test2 callArgs = nil.	self should: test2 size = 2.! !MySTExpression subclass: #MySTExpressionUnoCall	instanceVariableNames: 'message receiver'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionUnoCall methodsFor: 'accessing' stamp: 'SZ 1/10/2008 15:58'!callArgs	^nil! !!MySTExpressionUnoCall methodsFor: 'accessing' stamp: 'SZ 1/19/2008 21:02'!callMessage	^ message.! !!MySTExpressionUnoCall methodsFor: 'accessing' stamp: 'SZ 1/19/2008 21:01'!callTarget	^ receiver.! !!MySTExpressionUnoCall methodsFor: 'accessing' stamp: 'SZ 1/19/2008 21:05'!size	^ receiver  size + 1! !!MySTExpressionUnoCall methodsFor: 'accessing' stamp: 'SZ 1/19/2008 15:41'!whatType	^#unocallexpr.!]style[(11 13)f2,f2c255148000! !!MySTExpressionUnoCall methodsFor: 'initialize-release' stamp: 'SZ 1/22/2008 19:38'!initializeWith: aSourceString 	receiver := aSourceString first.	message := MySTExpressionLiteral newFrom: (OrderedCollection with: aSourceString second).	^self.	! !!MySTExpressionUnoCall methodsFor: 'compiling' stamp: 'SZ 2/4/2008 18:48'!compileIn: aMySTCompiledMethodOrBlock	receiver whatType = #primitivecall 		ifFalse: [				receiver compileIn: aMySTCompiledMethodOrBlock.			message compileIn: aMySTCompiledMethodOrBlock.			aMySTCompiledMethodOrBlock 				send: message 				to: receiver 				withArgs: nil 				result: self.]		ifTrue: [			aMySTCompiledMethodOrBlock 				callPrimitive: receiver primitiveNumber 				result: self.].	^self		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionUnoCall class	instanceVariableNames: ''!!MySTExpressionUnoCall class methodsFor: 'instance creation' stamp: 'SZ 2/4/2008 14:13'!newFrom: aSourceString 	aSourceString size > 1 		ifTrue: [			(#(#unocallexpr #cascadecall #blockexpr #bracketexpr #object #primitivecall ) includes: (self whoIs: aSourceString first))			& ((self whoIs: aSourceString second) = #name)				ifTrue: [^ super new initializeWith: aSourceString]].	^nil.! !MySTExpressionUnoCall subclass: #MySTExpressionBinCall	instanceVariableNames: 'arg'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionBinCall methodsFor: 'accessing' stamp: 'SZ 1/10/2008 15:56'!callArgs	^OrderedCollection with: arg.! !!MySTExpressionBinCall methodsFor: 'accessing' stamp: 'SZ 1/19/2008 21:01'!size	^ receiver size + 1 + arg size! !!MySTExpressionBinCall methodsFor: 'accessing' stamp: 'SZ 1/19/2008 15:43'!whatType	^#bincallexpr.!]style[(11 13)f2,f2c255148000! !!MySTExpressionBinCall methodsFor: 'initialize-release' stamp: 'SZ 2/18/2008 15:57'!initializeWith: aSourceString 	receiver := aSourceString first.	message := MySTExpressionLiteral newFrom: (OrderedCollection with: aSourceString second).	arg := (MySTExpressionBinCall				newExpressionFrom: (aSourceString allButFirst: 2)) first.	(#(#object #bracketexpr #blockexpr #unocallexpr) 		includes: (self whoIs: arg)) 			ifFalse: [^nil].				! !!MySTExpressionBinCall methodsFor: 'private' stamp: 'SZ 1/14/2008 19:23'!getBinArg: aSourceSting 	^ MySTExpressionBinCall newExpressionFrom: aSourceSting!]style[(11 12 5 21 20 12)f2b,f2cblue;b,f2,f2cmagenta;,f2,f2cblue;i! !!MySTExpressionBinCall methodsFor: 'compiling' stamp: 'SZ 1/25/2008 15:29'!compileIn: aMySTCompiledMethodOrBlock	receiver compileIn: aMySTCompiledMethodOrBlock.	message compileIn: aMySTCompiledMethodOrBlock.	arg compileIn: aMySTCompiledMethodOrBlock.	aMySTCompiledMethodOrBlock send: message to: receiver withArgs: self callArgs result: self.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionBinCall class	instanceVariableNames: ''!!MySTExpressionBinCall class methodsFor: 'as yet unclassified' stamp: 'SZ 1/20/2008 18:19'!canBeCascadeCall: aSourceString orReturn: anObject	aSourceString size < anObject size+1 ifTrue: [^anObject].	anObject 		ifNotNil: [			(aSourceString at: anObject size+1) = ';' 				ifTrue: [^MySTExpressionCascadeCall newWith: anObject] 				ifFalse: [^anObject]] 		ifNil: [^nil].! !!MySTExpressionBinCall class methodsFor: 'as yet unclassified' stamp: 'SZ 1/14/2008 19:19'!getExpression: aSourceString 	^self getExpressionAsBinCallArg: aSourceString.!]style[(15 13 9 27 13 1)f2b,f2cblue;b,f2,f2b,f2cblue;b,f2! !!MySTExpressionBinCall class methodsFor: 'as yet unclassified' stamp: 'SZ 2/4/2008 14:13'!newFrom: aSourceString 	aSourceString size < 3		ifTrue: [^nil].	(#(#object #cascadecall #unocallexpr #bincallexpr #block #bracketexpr ) 		includes: (self whoIs: aSourceString first))			& ((self whoIs: aSourceString second) = #binmessage)				ifFalse: [^nil]				ifTrue: [^super new initializeWith: aSourceString ].! !MySTExpressionUnoCall subclass: #MySTExpressionKeyCall	instanceVariableNames: 'args'	classVariableNames: ''	poolDictionaries: ''	category: 'MySTCompiler-Expressions'!!MySTExpressionKeyCall methodsFor: 'initialize-release' stamp: 'SZ 1/22/2008 19:39'!initializeWith: aSourceString 	receiver := aSourceString first.	message _ ''.	args _ OrderedCollection new.	self proccessMessageAndArgs: aSourceString copyWithoutFirst.	message _ MySTExpressionLiteral newFrom: (OrderedCollection with: message).! !!MySTExpressionKeyCall methodsFor: 'accessing' stamp: 'SZ 1/11/2008 21:24'!callArgs	^args.! !!MySTExpressionKeyCall methodsFor: 'accessing' stamp: 'SZ 1/14/2008 20:28'!callMessage	^ message!]style[(11 4 7)f2b,f2,f2cmagenta;! !!MySTExpressionKeyCall methodsFor: 'accessing' stamp: 'SZ 2/18/2008 15:21'!proccessMessageAndArgs: aSourceString 	| arg |	(self whoIs: aSourceString first) = #keymessage		ifFalse: [^ self].	message := message , aSourceString first.	arg := MySTExpressionKeyCall newExpressionFrom: aSourceString copyWithoutFirst.	args add: arg first.	arg size = 1		ifTrue: [^ self]		ifFalse: [^ self proccessMessageAndArgs: (aSourceString allButFirst: arg first size + 1)]! !!MySTExpressionKeyCall methodsFor: 'accessing' stamp: 'SZ 1/20/2008 18:39'!size	| result |	result _ receiver size.	args do: [:expr| result _ result + expr size + 1].	^result.! !!MySTExpressionKeyCall methodsFor: 'accessing' stamp: 'SZ 1/19/2008 15:40'!whatType	^#keycallexpr.!]style[(11 13)f2,f2c255148000! !!MySTExpressionKeyCall methodsFor: 'as yet unclassified' stamp: 'SZ 1/14/2008 20:54'!collectArguments: aSourceString 	| arg result src |	result := OrderedCollection new.	src := aSourceString.	[arg := MySTExpressionKeyCall newExpressionFrom: src.	result add: arg first.	arg size = 1		ifTrue: [^ result].	(arg at: 2) value = #keymessage]		whileTrue: [message := message , (arg at: 2) key.			src := src copyFrom: arg first key size + 2 to: src size].	^result.!]style[(18 13 4 15 4 6 4 17 7 3 4 13 4 3 4 21 20 3 3 6 6 3 9 3 8 1 14 6 5 3 5 1 10 11 16 7 4 7 4 3 5 1 10 3 4 3 11 3 18 1 5 3 17)f2b,f2cblue;b,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2c255148000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c255148000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cblue;i,f2,f2c255148000,f2,f2cblue;i,f2! !!MySTExpressionKeyCall methodsFor: 'compiling' stamp: 'SZ 2/2/2008 12:48'!compileIn: aMySTCompiledMethodOrBlock	receiver whatType = #primitivecall 		ifFalse: [			receiver compileIn: aMySTCompiledMethodOrBlock.			message compileIn: aMySTCompiledMethodOrBlock.			args do: [:arg| arg compileIn: aMySTCompiledMethodOrBlock.].			aMySTCompiledMethodOrBlock 				send: message 				to: receiver 				withArgs: self callArgs 				result: self.]		ifTrue: [			args do: [:arg| arg compileIn: aMySTCompiledMethodOrBlock.].			aMySTCompiledMethodOrBlock 				callPrimitive: receiver primitiveNumber 				withArgs: self callArgs 				result: self.].	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MySTExpressionKeyCall class	instanceVariableNames: ''!!MySTExpressionKeyCall class methodsFor: 'instance creation' stamp: 'SZ 2/4/2008 14:13'!newFrom: aSourceString 	aSourceString size < 3		ifTrue: [^ nil].	(#(#object #cascadecall #unocallexpr #bincallexpr #blockexpr #bracketexpr #primitivecall)			includes: (self whoIs: aSourceString first))			& ((self whoIs: aSourceString second) = #keymessage)		ifTrue: [^ super new initializeWith: aSourceString]		ifFalse: [^ nil]! !!MySTExpressionKeyCall class methodsFor: 'as yet unclassified' stamp: 'SZ 1/14/2008 19:22'!getExpression: aSourceString	^self getExpressionAsKeyCallArg: aSourceString.!]style[(63 13 1)f2b,f2cblue;b,f2! !